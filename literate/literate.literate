# Literate Programming

**Literate programming** is a programming paradigm introduced by Donald Knuth. A
program is written in a natural language with snippets of code interspersed.
From this text usable source code is generated, along with well formatted
human-readable document.

The most important influence for this **literate programming** extension is the
[PBR Book](https://pbr-book.org).

This extension provides a set of tools that help the programmer writing literate
programs. Through automation the process of writing literate programs should be
as painless as possible. The programming writes his literate programs using
Markdown. When a literate programmer needs a snippet they can add a code fence.
In this extension snippets are called code fragments.

The approach for this extension is based on Markdown documents, as noted
earlier. The Markdown specification is only slightly adapted to make supporting
**literate programming** easy. The code fragments are expressed in code fences
as per the Markdown specification, either with surrounding tripple backticks or
tripple tildes. Along with the programming language identifier the opening line
has been extended to contain the fragment name and type as essentially options
to the code fence. This opening line thus will look like
`py : <<fragment name>>` to create a new fragment, or like
`py : <<fragment name>>=+` to amend an existing fragment.

To create actual source files a fragment creation line needs to be used with a
slightly extended form of the creation tag mentioned above. The name has to be
postixed with the string `.*` betueen the chevrons. Furthermore a file
name needs to be specied after the equal sign. This is essentially a relative
path that is going to be appended each workspace folder as the root. A top level
fragment looks like `py : <<top-level fragment.*>> ./src/source.py`. The
name of this fragment is `top-level fragment`, and once it has been fully
extrapolated will be written to a file in the workspace folder under `src` as
the file `source.py`.

The **Literate Programming** extension allows the program author to write
multiple projects in the same Visual Studio Code workspace. Each workspace
folder is the root for its own literate project. Within each project there can
be one or more **literate** files. These files have the extension `.literate`.
One literate file can contain zero or more code fragments. A literate file can
also contain more than one top level fragment. In other words an author can
create multiple source files within just one **literate** document.

This text describes the **Literate Programming** extension as a **literate**
program.

## Iterating all literate files

As mentioned in the introduction the main idea of the extension is to collect
all fragments that are created in all `.literate` files. Once all fragments have
been collected they are extrapolated until the top fragments are the full source
files. Fully extrapolated top fragments are written to the source files as
specicied for them.

The first step is to put each `.literate` file through the *MarkdownIt*
renderer. Each rendering will be given a special environment that will be used
to collect the state for the render. The state will contain the document
tokenized according the Markdown specification. The state `env` is of type
`GrabbedState`. Among the tokens will be the code fences that are code
fragments. For each `.literate` file the grabbed state `env` is saved in the
list of `GrabbedState`s `envList`.

```ts : <<render and collect state>>=
async function iterateLiterateFiles(workspaceFolder : vscode.WorkspaceFolder,
                                    writeHtml : WriteRenderCallback
                                                | undefined
                                                | null,
                                    envList : Array<GrabbedState>,
                                    md : MarkdownIt)
{
  <<find all literate files in workspace>>
  try {
    for (let fl of foundLiterateFiles) {
      <<get text document content if available>>
      <<get text from literate document>>
      <<parse literate file>>
      <<write out rendered file if requested>>
    }
  } catch (error) {
    console.log(error);
  }
}
```

We ensure that only **literate** files are going to be parsed for their program
fragments. We do that by using a `vscode.RelativePattern` using the workspace
folder passed into `iterateLiterateFiles`.

``` ts : <<find all literate files in workspace>>=
const literateFilesInWorkspace : vscode.RelativePattern =
          new vscode.RelativePattern(workspaceFolder, '**/*.literate');
const foundLiterateFiles = await vscode.workspace
          .findFiles(literateFilesInWorkspace)
          .then(files => Promise.all(files.map(file => file)));
```

For each **literate** file in the workspace we'll get eventually the text
content, but we do have to check if any of the files are opened in an editor.
Especially for on-the-fly updating of the tree view, but also for fragment name
completion and similar functionality we need to get the text from the
`TextDocument` instead of the file on disk. If there is a `TextDocument` that
corresponds to the **literate** file we are currently handling we read the text
into `currentContent`, otherwise we set it to an empty string.

``` ts : <<get text document content if available>>=
const currentContent = (() =>
  {
    for(const textDocument of vscode.workspace.textDocuments) {
      if(vscode.workspace.asRelativePath(fl) === vscode.workspace.asRelativePath(textDocument.uri)) {
        return textDocument.getText();
      }
    }
    return '';
  }
)();
```

If `currentContent` is an empty string we read the content from the file on
disk, and decode it into `text`. If on the other hand we do have
`currentContent`, we use that for our `text` instead. The `currentContent`
wil be more up-to-date than what we have on disk.

``` ts : <<get text from literate document>>=
const content = currentContent ? null : await vscode.workspace.fs.readFile(fl);
const text = currentContent ? currentContent : new TextDecoder('utf-8').decode(content);
```

With the `text` for our **literate** document ready we harvest the relative file
path to our document from the workspace folder. `fname` is then set as the
`literateFileName` of our `GrabbedState` instance that we push into the
`envList` so that we can access it later. Now we finally get to pass the `text`
of our **literate** document to the *MarkdownIt* renderer. Once that is done we
have both an HTML representation of our document as well as the entire parser
state in `env`.

``` ts : <<parse literate file>>=
const fname = path.relative(workspaceFolder.uri.path, fl.path);
const env: GrabbedState = { literateFileName: fname, literateUri: fl, gstate: new StateCore('', md, {}) };
envList.push(env);
const rendered = md.render(text, env);
```

If a callback implementing `WriteRenderCallback` is passed to
`iterateLiterateFiles` we call that with the endered file content so that it can
be saved as an `HTML` file with the same name as the `.literate` file that was
being rendered, but with the extension replaced with `.html`. Conversely, if no
callback was passed in it is not called and rendered results are not saved to
disk.

``` ts : <<write out rendered file if requested>>=
if(writeHtml)
{
  await writeHtml(fname, workspaceFolder.uri, rendered);
}
```

### GrabbedState interface

The `GrabbedState` interface is used to create a type that helps us collecting
the tokens for each `.literate` file. Instances of objects with this interface
are passed to a *MarkdownIt* renderer. The renderer will have the
`GrabberPlugin` registered, which provides a rule that helps us collecting the
states of each rendered file. The grabbed state is collected in `gstate`, which
is an instance of the `StateCore`, provided by *MarkdownIt*.

``` ts : <<grabbed state type>>=
/**
 * Interface for environment to hold the Markdown file name and the StateCore
 * grabbed by the grabberPlugin.
 * The gstate we use to access all the tokens generated by the MarkdownIt parser.
 *
 * @see StateCore
 */
interface GrabbedState {
  /**
   * File name of the Markdown document to which the state belongs.
   */
  literateFileName: string;
  /**
   * Uri for the Markdown document.
   */
  literateUri: vscode.Uri;
  /**
   * State grabbed from the MarkdownIt parser.
   */
  gstate: StateCore;
}
```

## Preparing MarkdownIt

In the `iterateLiterateFiles` we start by setting up the *MarkdownIt* parser.

``` ts : <<set up MarkdownIt>>=
/**
  * MarkdownIt instance with grabber_plugin in use.
  */
const md : MarkdownIt = createMarkdownItParserForLiterate();
```

The function `createMarkdownItParserForLiterate` does this setup so that it is
easy to get a new parser to use for different purposes, like parsing documents
to get the code fragment names for code completion.

The highlight function we use to ensure our code fragments get syntax
highlighting. This simply relies on *highlight.js* to do the work.

We also tell *MarkdownIt* to use our `grabberPlugin`. This plug-in harvests the
internal states for each document into instances of `GrabbedState`. These states
we'll later use to get all the different code fragments and to weave them into
the code files they describe.

Finally we replace the default `fence` rule with our own `renderCodeFence` rule.
The intent of that rule will be explained in the section on `renderCodeFence`.

``` ts : <<create markdownit parser>>=
function createMarkdownItParserForLiterate() : MarkdownIt
{
  const md : MarkdownIt = new MarkdownIt({
          highlight: function(str: string, lang: string, attrs: string) {
            if(lang && hljs.getLanguage(lang)) {
              return '<pre><code>' +
              hljs.highlight(str, {language : lang}).value +
              '</code></pre>';
            }
            return '<pre title="' + attrs + '">' + md.utils.escapeHtml(str) + '</pre>';
          }
      
        })
        .use(grabberPlugin);
      
      oldFence = md.renderer.rules.fence;
      md.renderer.rules.fence = renderCodeFence;
  return md;
}
```

## Fragment structure and regular expressions

Before we dive deeper into the processing of `.literate` documents it is
necessary to have a look at how fragments work.

Fragments in the `literate` extension have a specific format that requires a bit
of explaining.

There are four types of fragment tags, three of which either create or modify a
fragment, and one that expresses fragment usage.

For the detection of fragments a couple of regular expressions are used. These
are explained in more detail below.

### Fragment use in code

Lets start by looking at the form for fragment tag use.

Fragments can be used in code blocks by using their tag double opening and
closing chevrons around the fragment name `<<fragment name>>`. To detect usage
of fragments in code we use `FRAGMENT_USE_IN_CODE_RE`.

``` ts : <<fragment regular expressions>>=
//let HTML_ENCODED_FRAGMENT_TAG_RE = /(&lt;&lt.*?&gt;&gt;)/g;
let FRAGMENT_USE_IN_CODE_RE =
  /(?<indent>[ \t]*)<<(?<tagName>.*)>>(?<root>=)?(?<add>\+)?/g;
```

The regular expression captures four groups. A match will give us 5 or more
results, the whole string matched and the captured groups. There may be some
additional parts after that, but those we will discard. The whole string matched
is called the `tag`. The first group is called `indent`, which will be used to
indent the whole fragment code when it gets extrapolated into the final code.
The second group is called `tagName`, which is the fragment name. The third
group is called `root` and the final group is called `add`. For fragment use we
essentially need only the second group `tagName`, with the `indent` still
serving a function. The other groups are in the regular expression so we can
identify incorrect use of fragments in code: creating or adding to fragments
inside code blocks is not valid.

The application of `FRAGMENT_USE_IN_CODE_RE` is explained in more detail in the
section on code realization.

### Creating and modifying fragments

There is the tag used to create a new fragment, which is always in conjunction
with the opening code fence tag. This means either a triple backtick or triple
tilde followed by the programming language identifier for the following code
block. The actual fragment tag is placed as first option right after the colon
following the language specifier.

``` ts : <<fragment regular expressions>>=+
let FRAGMENT_RE =
  /(?<lang>.*):.*<<(?<tagName>.*)>>(?<root>=)?(?<add>\+)?\s*(?<fileName>.*)/;
```

Most of the groups correspond to the ones defined by `FRAGMENT_USE_IN_CODE_RE`
with a few additions. Most notably there is the group catching the language
specifier, and the group to catch the filename, called `lang` and `fileName`
respectively.

So to create a new tag the info line for the code fence could look like
`py : <<a fragment name>>=`.

To add to a fragment a `+` is added, so it could look like
`py : <<a fragment name>>=+`. Having a fragment without `=` or `=+` on the code
fence info line is an error.

## Gathering all fragments

All code fragments are fetched from each environment state. This is done through
looking for all `fence` tokens. If the `token.info` for a `fence` matches the
`FRAGMENT_RE` we can check to see whether the fragment we have currently in our
hands is a new fragment (`root && !add`) or whether this one expands an existing
one (`root && add`), as will be explained in more detail further down.

```ts : <<handle fragments>>=
async function handleFragments(
  workspaceFolder : vscode.WorkspaceFolder,
  envList : Array<GrabbedState>,
  diagnostics : vscode.DiagnosticCollection,
  extrapolateFragments : boolean,
  writeSource : WriteSourceCallback | undefined) : Promise<Map<string, FragmentInformation>>
{
  const folderUri = workspaceFolder.uri;
  <<build fragment map>>

  if(extrapolateFragments)
  {
    <<extrapolate fragments>>
  }

  if(writeSource) {
    writeSource(workspaceFolder, fragments);
  }

  return Promise.resolve(fragments);
}
```

```ts : <<write out source files>>=
async function writeSourceFiles(workspaceFolder : vscode.WorkspaceFolder,
                fragments : Map<string, FragmentInformation>)
{
  const folderUri = workspaceFolder.uri;
  /* now write out the source files. */
  for(const name of fragments.keys()) {
    if (name.indexOf(".*") >= 0) {
      let fragmentInfo = fragments.get(name) || undefined;
      if (fragmentInfo) {
        let fileName = fragmentInfo.sourceFileName.trim();
        const encoded = Buffer.from(fragmentInfo.code, 'utf-8');
        const fileUri = vscode.Uri.joinPath(folderUri, fileName);
        await vscode.workspace.fs.writeFile(fileUri, encoded);
      }
    }
  }
}
```

### Populating the fragment map

First we build a map of all available fragments. These will go into `fragments`,
which is of type `Map<string, FragmentInformation>`. The name of a fragment will
function as the key, and an instance of `FragmentInformation` will be the value.

```ts : <<build fragment map>>=
/**
 * Map of fragment names and tuples of code fragments for these. The
 * tuples contain code language identifier followed by the filename and
 * lastly followed by the actual code fragment.
 */
const fragments = new Map<string, FragmentInformation>();
// Now we have the state, we have access to the tokens
// over which we can iterate to extract all the code
// fragments and build up the map with the fragments concatenated
// where necessary. We'll extrapolate all fragments in the second
// pass.
for (let env of envList) {
  for (let token of env.gstate.tokens) {
    <<handle fence tokens>>
  }
}
```

Each `fence` token we find we need to check. There may be of course code fences
in the document that do not create or modify a fragment. These we need to skip.

Since we are handling code fences we use `FRAGMENT_RE` to match `token.info`.

```ts : <<handle fence tokens>>=
if (token.type === 'fence') {
  const linenumber = locationOfFragment(token);
  const match = token.info.match(FRAGMENT_RE);
  if (match && match.groups) {
    let lang = match.groups.lang.trim();
    let name = match.groups.tagName;
    let root = match.groups.root;
    let add = match.groups.add;
    let fileName = match.groups.fileName;
    <<add to existing fragment>>
    <<create a new fragment>>
  }
}
```

### Creating a new fragment

If the `root` group has captured a result, but the `add` group not we know we
have a new fragment on our hand.

If we already have in our `fragments` map a key with the same `name` as the
fragment we are currently handling we add an error diagnostic message. We don't
stop handling fences, or the entire `literate.process` command for that matter.
We keep on going, but leave it up to the programmer to see and handle the error
messages.

If a fragment name with `.*` is found we need to ensure there is a result in the
`fileName` capture group. That is going to be needed to write out the source
code file eventually. A file defining fragment without a file name is an error.

When everything appears to be in order a new `FragmentInformation` instance is
created with the information found. The code for this fragment is the token
content in `token.content`. Finally the new `FragmentInformation` instance is
added to the `fragments` map.

``` ts : <<create a new fragment>>=
if (root && !add) {
  if (fragments.has(name)) {
    let msg = `Trying to overwrite existing fragment fragment ${name}. ${env.literateFileName}${linenumber}`;
    const diag = createErrorDiagnostic(token, msg);
    updateDiagnostics(env.literateUri, diagnostics, diag);
  } else {
    if (!fileName && name.indexOf(".*") > -1) {
      let msg = `Expected filename for star fragment ${name}`;
      const diag = createErrorDiagnostic(token, msg);
      updateDiagnostics(env.literateUri, diagnostics, diag);
    } else {
      let code = token.content;
      let fragmentInfo: FragmentInformation = {
        lang: lang,
        literateFileName: env.literateFileName,
        sourceFileName: fileName,
        code: code,
        tokens: [token],
        env: env,
      };
      fragments.set(name, fragmentInfo);
    }
  }
}
```

### Modifying an exiting fragment

If both the `root` and `add` groups have capture their results, an `=` and an
`+` respectively we need to add code to an existing fragment.

For this to work a new fragment needs to be always present before the modifying
fragment. It is an error to try to modify a fragment that hasn't been seen yet.

The fragment with specified `name` is fetched, and when it is not `undefined`
the `token.content` is appended to the `code` of the `FragmentInformation`
instance we got from the map. The current token is also appended to the `tokens`
list.

The fragments map is updated with the modified  `FragmentInformation` instance.

``` ts : <<add to existing fragment>>=
if (root && add) {
  if (fragments.has(name)) {
    let fragmentInfo = fragments.get(name) || undefined;
    if(fragmentInfo && fragmentInfo.code) {
      let additionalCode = token.content;
      fragmentInfo.code = `${fragmentInfo.code}${additionalCode}`;
      fragmentInfo.tokens.push(token);
      fragments.set(name, fragmentInfo);
    }
  } else {
    let msg = `Trying to add to non-existant fragment ${name}. ${env.literateFileName}:${linenumber}`;
    const diag = createErrorDiagnostic(token, msg);
    updateDiagnostics(env.literateUri, diagnostics, diag);
  }
}
```

### The FragmentInformation type

We have now seen the `FragmentInformation` type being used several times, so it
is important to take a moment to clarify it in more detail.

The interface allows us to gather information for each found code fragment. It
allows us to store the programming language identifier, name of the `.literate`
file and name of the targeted source file, if the code fragment happens to be a
top fragment.

The actual code for the fragment is stored in `code`. Furthermore the tokens for
the complete fragment are stored in the `tokens` list. This list is of objects
that fullfill the `Token` interface, which is provided by the *MarkdownIt*
module.

``` ts : <<fragment information type>>=
/**
 * Interface denoting a fragment and related information
 */
interface FragmentInformation {
  /**
   * Programming language identifier for fragment.
   */
  lang: string;
  /**
   * Filename of literate file.
   */
  literateFileName: string;
  /**
   * Filename of target source file. This is set when the fragment
   * is a top fragment.
   */
  sourceFileName: string;
  /**
   * The code fragment.
   */
  code: string;
  /**
   * List of tokens that make up the entire code fragment.
   */
  tokens: Token[];
  /**
   * The GrabbedState related to this fragment.
   */
  env: GrabbedState;
}
```

## Extrapolating fragments

Once all fragments have been collected from the `.literate` files of the project
fragments can be combined into source code.

``` ts : <<extrapolate fragments>>=
// for now do several passes
let pass: number = 0;
do {
  pass++;
  let fragmentReplaced = false;
  for (let fragmentName of fragments.keys()) {
    let fragmentInfo = fragments.get(fragmentName) || undefined;
    if (!fragmentInfo) {
      continue;
    }

    const casesToReplace = [...fragmentInfo.code.matchAll(FRAGMENT_USE_IN_CODE_RE)];
    for (let match of casesToReplace) {
      if(!match || !match.groups) {
        continue;
      }
      let tag = match[0];
      let indent = match.groups.indent;
      let tagName = match.groups.tagName;
      let root = match.groups.root;
      let add = match.groups.add;
      if (root) {
        let msg = `Found '=': incorrect fragment tag in fragment, ${tag}`;
        const diag = createErrorDiagnostic(fragmentInfo.tokens[0], msg);
        updateDiagnostics(fragmentInfo.env.literateUri, diagnostics, diag);
      }
      if (add) {
        let msg = `Found '+': incorrect fragment tag in fragment: ${tag}`;
        const diag = createErrorDiagnostic(fragmentInfo.tokens[0], msg);
        updateDiagnostics(fragmentInfo.env.literateUri, diagnostics, diag);
      }
      if (!fragments.has(match.groups.tagName) && tagName !== "(?<tagName>.*)") {
        let msg = `Could not find fragment ${tag} (${tagName})`;
        const diag = createErrorDiagnostic(fragmentInfo.tokens[0], msg);
        updateDiagnostics(fragmentInfo.env.literateUri, diagnostics, diag);
      }
      let fragmentToReplaceWith = fragments.get(tagName) || undefined;
      if (fragmentToReplaceWith) {
        let code = fragmentToReplaceWith.code;
        let lines = code.split("\n").slice(0, -1);
        let indentedLines = lines.flatMap(function (e, _) {
          return indent + e;

        });
        let newcode = indentedLines.join("\n");
        fragmentReplaced = true;
        fragmentInfo.code = fragmentInfo.code.replace(tag, newcode);
        fragments.set(fragmentName, fragmentInfo);
      }
    }
  }
  if(!fragmentReplaced) {
    break;
  }
}
while (pass < 25);
```

## custom code fence rendering

Our extension uses a custom code fence rendering rule to ensure the code
fragment name is also rendered as part of the fence.

Essentially the old, default rendering rule for fences is first used to create
the original fence.

Then the `token.info` is matched against the `FRAGMENT_RE` regular expression.
If we have a match we prepare the `HTML` code to essentially wrap around the
`HTML` as generated by the default rule.

```ts : <<renderCodeFence rule>>=
function renderCodeFence(tokens : Token[],
             idx : number,
             options : MarkdownIt.Options,
             env : any,
             slf : Renderer) {
  let rendered = '';
  if (oldFence) {
    rendered = oldFence(tokens, idx, options, env, slf);

    let token = tokens[idx];
    if (token.info) {
      const match = token.info.match(FRAGMENT_RE);
      if (match && match.groups) {
        let lang = match.groups.lang.trim();
        let name = match.groups.name;
        let root = match.groups.root;
        let add = match.groups.add;
        let fileName = match.groups.fileName;
        if (name) {
          root = root || '';
          add = add || '';
          rendered =
`<div class="codefragment">
<div class="fragmentname">&lt;&lt;${name}&gt;&gt;${root}${add}</div>
<div class="code">
${rendered}
</div>
</div>`;
        }
      }
    }
  }

  return rendered;
};
```

## Register the literate.process command

The command `literate.process` is registered with Visual Studio Code. The
disposable that gets returned by `registerCommand` is held in
`literateProcessDisposable` so that it can be used later on, for instance for
diagnostics management.

Here we find the main program of our `literate.process` command. Our
*MarkdownIt* is set up, `.literate` files are searched and iterated. Each
`.literate` file is rendered, and code fragments are harvested. Finally code
fragments are extrapolated and saved to their respective source code files. The
`HTML` files are also saved to files.

Diagnostic messages are also handled here. Errors and warnings are shown where
necessary. On successfull completion a simple status bar message will be used.
An information diagnostic message is not good here, because that will prevent
the usage of `literate.process` in for instance `tasks.json`, since the
diagnostic message will block execution of a task if it were used as prelaunch
task. That is obviously not good for the workflow.

```ts : <<register literate.process>>=
let literateProcessDisposable = vscode.commands.registerCommand(
  'literate.process',
  async function () {

  <<set up MarkdownIt>>

  diagnostics.clear();

  if (!vscode.workspace.workspaceFolders) {
    return vscode.window.showInformationMessage("No workspace or folder opened");
  }


  const writeOutHtml : WriteRenderCallback =
      (fname : string,
       folderUri : vscode.Uri,
       rendered : string) : Thenable<void> => {
    const html =
`<html>
  <head>
    <link rel="stylesheet" type="text/css" href="./style.css">
  </head>
  <body>
  ${rendered}
  </body>
</html>`;
    const encoded = Buffer.from(html, 'utf-8');
    fname = fname.replace(".literate", ".html");
    const fileUri = vscode.Uri.joinPath(folderUri, fname);
    return Promise.resolve(vscode.workspace.fs.writeFile(fileUri, encoded));
  };

  for(const workspaceFolder of vscode.workspace.workspaceFolders) {
    const envList: Array<GrabbedState> = new Array<GrabbedState>();
    await iterateLiterateFiles(workspaceFolder, writeOutHtml, envList, md);
        let _ = await handleFragments(workspaceFolder, envList, diagnostics, true, writeSourceFiles);
  }

  let hasAnyDiagnostics = false;
  diagnostics.forEach(
    function(
      _: vscode.Uri,
      diags: readonly vscode.Diagnostic[],
      __: vscode.DiagnosticCollection
    ) : any {
      hasAnyDiagnostics ||= (diags.length > 0);
    }
  );

  if (hasAnyDiagnostics) {
        return vscode.window.setStatusBarMessage(
            (new vscode.MarkdownString(
        "$(error) Error encountered during process"
      )).value, 2000);
  }
  else {
    return vscode.window.setStatusBarMessage("Literate Process completed", 5000);
  }
});
```

## Fragment explorer

The Literate Fragment Explorer is a `TreeView` that uses `FragmentNodeProvider`
to show fragments available in a workspace. The tree view has `FragmentNode` as
its type parameter.

``` ts : <<fragment explorer>>=
export class FragmentExplorer {
  private fragmentView : vscode.TreeView<FragmentNode>;
  constructor(context : vscode.ExtensionContext) {
    const fragmentNodeProvider = new FragmentNodeProvider();
    context.subscriptions.push(
      vscode.window.registerTreeDataProvider(
        'fragmentExplorer',
        fragmentNodeProvider
      )
    );
    this.fragmentView = vscode.window.createTreeView(
                  'fragmentExplorer',
                  {
                    treeDataProvider : fragmentNodeProvider
                  });

    context.subscriptions.push(
      vscode.commands.registerCommand(
                'fragmentExplorer.refreshEntry',
                () => fragmentNodeProvider.refresh())
              );
    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(
      _ => {
        fragmentNodeProvider.refresh();
      }
    ));
    context.subscriptions.push(this.fragmentView);
  }
}
```

### Fragment tree provider

The Literate Fragment Explorer needs a
[`TreeDataProvider`](https://code.visualstudio.com/api/extension-guides/tree-view)
implementation to present the fragment structure to Visual Studio Code so that
the data can be visualized in the `fragmentExplorer` custom view.

The class `FragmentNodeProvider` implements a `TreeDataProvider` with
`FragmentNode` as the tree item.

``` ts : <<fragment tree provider>>=
export class FragmentNodeProvider implements vscode.TreeDataProvider<FragmentNode>
{
  <<fragment node provider members>>
  <<fragment node provider API>>
}
```

The constructor takes care of all necessary initialization.

``` ts : <<fragment node provider API>>=
constructor()
{
  <<initialize fragment node provider>>
}
```

The constructor for the `FragmentNodeProvider` creates an instance of the
`MarkdownIt` module, fully configured for our **literate programming** needs.
Additionally a `DiagnosticCollection` is created so that it can be passed on to
the `handleFragments` function that is utilized in the `FragmentNodeProvider`.

``` ts : <<initialize fragment node provider>>=
this.md = createMarkdownItParserForLiterate();
this.diagnostics = vscode.languages.createDiagnosticCollection('literate-treeview');
```

This means we need two members to hold these instances.

``` ts : <<fragment node provider members>>=
private md : MarkdownIt;
private diagnostics : vscode.DiagnosticCollection;
```

The API for `FragmentNodeProvider` gives as method to update the tree view

``` ts : <<fragment node provider API>>=+
refresh(): void {
  <<refresh fragment node provider>>
}
```

The current implementation simply fires the `onDidChangeTreeData` event but
could do more work if needed. To that end there is a private member for emitting
the event, and the actual event to which the event emitter is published.

``` ts : <<fragment node provider members>>=+
private _onDidChangeTreeData:
  vscode.EventEmitter<
    FragmentNode |
    undefined |
    void
  > = new vscode.EventEmitter<FragmentNode | undefined | void>();
readonly onDidChangeTreeData :
  vscode.Event<
    FragmentNode |
    undefined |
    void
  > = this._onDidChangeTreeData.event;
```

With those two in place the `refresh` function can fire the event whenever
called.

``` ts : <<refresh fragment node provider>>=
this._onDidChangeTreeData.fire();
```

The `TreeDataProvider` implementation provided by `FragmentNodeProvider` is
completed by `getTreeItem` and `getChildren`. The first one is simple, it just
returns the element that is passed to it, as there is no need to find out more
information about this. Instead, elements have been already created by the
`getChildren` function, where all `FragmentNode` instances are created with all
the data necessary.

``` ts : <<fragment node provider API>>=+
getTreeItem(element : FragmentNode): vscode.TreeItem {
  <<get fragment tree item>>
}
```

As said, the `getTreeItem` implementation remains simple

``` ts : <<get fragment tree item>>=
return element;
```

On the other hand the `getChildren` function is more involved. Yet its job is
simple: get all `FragmentNode`s that represent the direct children of the
element given.

``` ts : <<fragment node provider API>>=+
async getChildren(element? : FragmentNode): Promise<FragmentNode[]>
{
  <<get direct children>>
}
```

When the workspace has no workspace folders at all there will be no children to
return, as there are no **literate** documents to begin with.

``` ts : <<get direct children>>=
if(!vscode.workspace.workspaceFolders ||
  (
    vscode.workspace.workspaceFolders &&
    vscode.workspace.workspaceFolders.length < 1
  )) {
  vscode.window.showInformationMessage('No fragments in empty workspace');
  return Promise.resolve([]);
}
```

If we do have workspace folders, but no element is given to look for children we
need to look at the all the fragments available in all documents across all
workspace folders. If on the other hand an element is given then its children
are retrieved.

``` ts : <<get direct children>>=+
if(!element)
{
  <<get children for workspace folders>>
}
else
{
  <<get children for element>>
}
```

When no element is passed we want the root of all the branches, where each
workspace folder is the root of its own branch.

To this end the children are all essentially the workspace folder names. Since
these are the work folders the fragments representing them have no `parentName`
specified. As `folderName` we pass on the workspace folder name. This is a
property all its children and the rest of its offspring inherit. The
`folderName` is used to find the correct workspace folder to search for the
given element and its offspring.

``` ts : <<get children for workspace folders>>=
let arr = new Array<FragmentNode>();
for(const wsFolder of vscode.workspace.workspaceFolders)
{
    arr.push(
    new FragmentNode(
      wsFolder.name,
      new vscode.MarkdownString('$(book) (workspace folder)', true),
      'Workspace folder containing a literate project',
      vscode.TreeItemCollapsibleState.Collapsed,
      wsFolder.name,
      undefined,
      wsFolder,
      undefined));
}
return Promise.resolve(arr);
```

Getting the children for a given element is a bit more involved. First we set
up a constant `folderName` for ease of access. Then we also creat an array of
`FragmentNode`s.

``` ts : <<get children for element>>=
const folderName : string = element.folderName;
const fldr : vscode.WorkspaceFolder = element.workspaceFolder;
let arr = new Array<FragmentNode>();
```

From the element we already learned the workspace folder for its project, so we
can use that directly to parse the **literate** content. With the `fragments`
map of the workspace folder in hand we can iterate over the keys in the
`fragments` map.

There are essentially two cases we need to check for. If the given element has
no `parentName` set we know it is a fragment in the document level, so a
fragment that was created. In contrast for a fragment there are child fragments,
meaning that in the fragment code block other fragments were used. These are
presented in the tree view as children to that fragment.

``` ts : <<get children for element>>=+
<<get fragment family for offspring search>>
for(const fragmentName of fragments.keys() )
{
  if(!element.parentName) {
    <<create fragment node for document level>>
  }
  else if (fragmentName === element.label) {
    <<create fragment node for fragment parent>>
  }
}

return Promise.resolve(arr);
```

### Getting all fragments

To find the fragment information to build `FragmentNode`s from iterate over the
**literate** files in the workspace folder that we determined we need to search.
Then build the fragment map based on the tokens generated by the iteration pass.
As a reminder the fragments map has the fragment name as key and the
corresponding `FragmentInformation` as the value to that key.

``` ts : <<get fragment family for offspring search>>=
let envList: Array<GrabbedState> = new Array<GrabbedState>();
await iterateLiterateFiles(fldr, undefined, envList, this.md);
const fragments = await handleFragments(fldr, envList, this.diagnostics, false, undefined);
```

### TODO: build proper fragment hierarchy from fragments map

Still to do. Right now essentially the map structure is shown, but that isn't
very useful. What we really need is a hierarchical form with each fragment under
its parent fragment so that the structure of the literate program can be seen.

Another improvement we could make is to show Markdown outline of chapters, with
fragment occurance under that shown.

### Fragment used in other fragment

When we have found the fragment the passed in element represents we can find the
child fragment names, that is the fragment names used in this fragment. All
matches against `FRAGMENT_USE_IN_CODE_RE` are found and for each case a
corresponding `FragmentNode` is created to function as a child to our parent
element.

``` ts : <<create fragment node for fragment parent>>=
let fragmentInfo = fragments.get(fragmentName) || undefined;
if (fragmentInfo) {
  const casesToReplace = [...fragmentInfo.code.matchAll(FRAGMENT_USE_IN_CODE_RE)];
  for (let match of casesToReplace) {
    if(!match || !match.groups)
    {
      continue;
    }
    let tag = match[0];
    let ident = match.groups.ident;
    let tagName = match.groups.tagName;
    let root = match.groups.root;
    let add = match.groups.add;
    arr.push(
      new FragmentNode(
        tagName,
                new vscode.MarkdownString(`$(symbol-file) ${fragmentInfo.literateFileName}`, true),
        fragmentName,
        vscode.TreeItemCollapsibleState.Collapsed,
        folderName,
        element.label,
        element.workspaceFolder,
        undefined
      )
    );
  }
}
```

### Fragment on document level

When the workspace folder is given as the element, or rather the `parentName`
of the given element is undefined, we have a fragment on document level. There
are two types of fragments we want to discern beetween: top level fragments, or
fragments that also tell us what file to create, and other fragments. A
**literate** document can contain multiple top level fragments. But each top
level fragment will generate only one source code file.

``` ts : <<create fragment node for document level>>=
let fragmentType : vscode.MarkdownString;
let fragmentInfo = fragments.get(fragmentName) || undefined;
if (fragmentInfo) {
  if(fragmentName.indexOf(".*") >= 0)
  {
    fragmentType = new vscode.MarkdownString(
              `$(globe): ${fragmentInfo.literateFileName}`,
              true);
  }
  else
  {
    fragmentType = new vscode.MarkdownString(
              `$(code): ${fragmentInfo.literateFileName}`,
              true);
  }
    arr.push(
    new FragmentNode(
      fragmentName,
      fragmentType,
      fragmentInfo.literateFileName,
      vscode.TreeItemCollapsibleState.Collapsed,
      folderName,
      element.label,
      element.workspaceFolder,
      undefined));
}
```

### Fragment node for tree view

A fragment node represents a **literate** project fragment in a Visual Studio
Code tree view. The class `FragmentNode` extends the `vscode.TreeItem`. Apart
from just showing basic information like the fragment name and the file it is
defined in we use `FragmentNode` also to keep track of the workspace folder it
is hosted in as well as the text document if there is one. Text documents are
documents the workspace currently has opened. We need to take these into
account so that we can directly use these as part of the **literate** document
parsing.

``` ts : <<fragment node>>=
class FragmentNode extends vscode.TreeItem
{
  constructor (
    <<fragment node readonly members>>
  )
  {
    <<fragment node initialization>>
  }
}
```

For the visualization part we need a `label`, a `tooltip`, a `description` and a
`collapsibleState`. These are the only pieces of information needed that show up
in the tree view.

``` ts : <<fragment node readonly members>>=
public readonly label : string,
public readonly tooltip : vscode.MarkdownString,
public readonly description : string,
public readonly collapsibleState : vscode.TreeItemCollapsibleState,
```

We further encode some more information in `FragmentNode` so that subsequent
parsing can be done much more efficiently.

``` ts : <<fragment node readonly members>>=+
public readonly folderName: string,
public readonly parentName : string | undefined,
public readonly workspaceFolder : vscode.WorkspaceFolder,
public readonly textDocument : vscode.TextDocument | undefined
```

Each node in the tree view represents a fragment. When the tree item is used to
denote a workspace folder the theme icon for `'book'` is used. Actual fragments
get the theme icon for `'code'`.

``` ts : <<fragment node initialization>>=
super(label, collapsibleState);
this.tooltip = tooltip;
this.description = description;
this.iconPath = this.parentName ?
          new vscode.ThemeIcon('code')
          : new vscode.ThemeIcon('book');
this.contextValue = 'literate_fragment';
```

### registering FragmentNodeProvider

The `FragmentNodeProvide` needs to be registered with Visual Studio Code so it
can work when literate files are found in a work space.

``` ts : <<register fragment tree view>>=
new FragmentExplorer(context);
```

## Code completion

A simple implementation to provide code completion will help authors writing
their literate programs. Having possible tag names suggested will help
decreasing the cognitive load of remembering all code fragment names in a
literate project. This project itself has well over 50 fragments, and having to
remember them by name is not easy.

Until there is a good **literate** file type integration with Visual Studio Code
we'll be relying on the built-in **Markdown** functionality.

``` ts : <<register completion item provider>>=
const completionItemProvider =
  vscode.languages.registerCompletionItemProvider('markdown', {
    <<implement provide completion items>>
}, '<');
context.subscriptions.push(completionItemProvider);
```

### Providing completion items

The completion item provider will generate a `CompletionItem` for each fragment
we currently know of. Although the provider gets passed in the `TextDocument`
for which it was triggered we will present fragments from the entire project.

``` ts : <<implement provide completion items>>=
async provideCompletionItems(
  document : vscode.TextDocument,
  ..._
)
{
```

After setting up the necessary variables with
`<<setup variables for providing completion items>>` we figure out to which
workspace folder the current `TextDocument`. If no workspace folder can be
determined we return an empty array. This can happen with an unsaved new file,
or when documents were opened that are not part of the workspace.

``` ts : <<implement provide completion items>>=+
  <<setup variables for providing completion items>>
  <<get workspace for TextDocument>>
```

After the workspace folder has been determined we can gather all fragments in
our project.

``` ts : <<implement provide completion items>>=+
  <<get fragments for completion items>>
```

Finally we generate the completion items into the array `completionItems` that
we return when done.

``` ts : <<implement provide completion items>>=+
  <<for each fragment create a completion item>>
  return completionItems;
}
```

#### Setting up variables

Completion items are going to be collected in an `Array<CompletionItem>`.
Further,  creating completion items for code completion needs to parse the
entire project, so we need an `Array<GrabbedState>`. Iterating and parsing
through the project also needs a `DiagnosticCollection`, although we won't be
using it any further. Lastly we create an instance of the *MarkdownIt* parser to
give to `iterateLiterateFiles`.

``` ts : <<setup variables for providing completion items>>=
let completionItems : Array<vscode.CompletionItem> =
    new Array<vscode.CompletionItem>();
let envForCompletion : Array<GrabbedState> = new Array<GrabbedState>();
    new Array<vscode.CompletionItem>();
const diagnostics = vscode.languages.createDiagnosticCollection('literate-completionitems');
const md : MarkdownIt = createMarkdownItParserForLiterate();
```

#### Workspace folder for TextDocument

Determining the workspace folder for the given TextDocument is done by creating
relative paths from each workspace folder to the document. If the path does not
start with `..` we found the workspace folder where the document is from.

If no workspace folders were found, or if the TextDocument did not have a
workspace folder we essentially end up returning an empty array from the
completion item provider.

``` ts : <<get workspace for TextDocument>>=
const workspaceFolder : vscode.WorkspaceFolder | undefined = determineWorkspaceFolder(document);
if(!workspaceFolder) { return []; }
```

#### Retrieving fragments of project

Getting the fragments for our project means we `iterateLiterateFiles`with the
`envForCompletion` given, along with the workspace folder and the *MarkdownIt*
parser. Once we have iterated over all files, and thus `envForCompletion` now
contains all literate documents tokenized we can pass those to `handleFragments`
so we can end up with a map of all fragments. We pass in `false` to the function
to ensure fragments aren't extrapolated: we want to show the fragments as they
are in code completion.

``` ts : <<get fragments for completion items>>=
  await iterateLiterateFiles(workspaceFolder, undefined, envForCompletion, md);
  let fragments = await handleFragments(workspaceFolder, envForCompletion, diagnostics, false, writeSourceFiles);
```

#### Creating the CompletionItems

With all fragments in the map we iterate over all the keys. For each key we
fetch the corresponding `FragmentInformation`. Now we can create the
`CompletionItem` with the `fragmentName` as its content.

Further the fragment code is set to be the detail of the completion item. This
will provide a tooltip with the code fragment readable, so that it is easy to
understand what fragment is currently highlighted in the completion list.

Finally the set the completion item kind to `Reference` so that we get a nice
icon in the completion list pop-up.

``` ts : <<for each fragment create a completion item>>=
  for(const fragmentName of fragments.keys())
  {
    const fragment : FragmentInformation | undefined = fragments.get(fragmentName);
    if(!fragment) {
      continue;
    }
    const fragmentCompletion = new vscode.CompletionItem(fragmentName);
    fragmentCompletion.detail = fragment.code;
    fragmentCompletion.kind = vscode.CompletionItemKind.Reference;
    completionItems.push(fragmentCompletion);
  }
```

## Hover elements

In addition to code completion we can provide hover information. We want to see
the implementation of fragments when hovering of fragment usages. That way code
inspection can be easier done.

We'll create `FragmentHoverProvider` which implements `HoverProvider`.

``` ts : <<fragment hover provider>>=
class FragmentHoverProvider implements vscode.HoverProvider {
  <<hover provider method>>
}
```

The `FragmentHoverProvider` implements `provideHover`. This will create the
`Hover` item if under the current cursor position there is a fragment, including
its opening and closing double chevrons.

``` ts : <<hover provider method>>=
public async provideHover(
  document : vscode.TextDocument,
  position : vscode.Position,
  _: vscode.CancellationToken
)
{
  <<get current line>>
  <<find workspace folder for hover detection>>
  <<create hover item for fragment>>
  return null;
}
```

We get the current line of text from the document. We are going to look only for
tags that are on one line. In the future it would be nice to add support for
cases where mentioning a fragment in explaining text is split over several lines
due to word wrapping, but with the current implementation we'll look only at
those that are on one line.

``` ts : <<get current line>>=
const currentLine = document.lineAt(position.line);
```

Next we need to know the the workspace folder for the given document so that we
can query the correct project for the fragments. If no workspace folder was
determined return `null`, as there is no literate project associated with the
given document.

``` ts : <<find workspace folder for hover detection>>=
const workspaceFolder : vscode.WorkspaceFolder | undefined = determineWorkspaceFolder(document);
if(!workspaceFolder) { return null; }
```

Fragments are now available so we can see if we have a fragment under our
cursor. If we do, and the fragment is not one that defines or appends to a
fragment we know our cursor is over either fragment usage in a code fence or a
fragment mention in explaining text. For this we can create a `Hover` with the
code of the fragment as a `MarkdownString` in a code fence.

If that is not the case our `provideHover` implementation will return `null`.

``` ts : <<create hover item for fragment>>=
const matchesOnLine = [...currentLine.text.matchAll(FRAGMENT_USE_IN_CODE_RE)];
for(const match of matchesOnLine)
{
  if(!match || !match.groups) {
    continue;
  }
  const foundIndex = currentLine.text.indexOf(match[0]);
  if(foundIndex>-1) {
    <<get fragments for hover detection>>
    if(foundIndex <= position.character && position.character <= foundIndex + match[0].length && fragments.has(match.groups.tagName))
    {
      const startPosition = new vscode.Position(currentLine.lineNumber, foundIndex);
      const endPosition = new vscode.Position(currentLine.lineNumber, foundIndex + match[0].length);
      let range : vscode.Range = new vscode.Range(startPosition, endPosition);
      let fragment = fragments.get(match.groups.tagName) || undefined;
      if (fragment && !match.groups.root) {
        return new vscode.Hover(
          new vscode.MarkdownString(`~~~ ${fragment.lang}\n${fragment.code}\n~~~`, true),
          range);
      }
    }
  }
}
```

With the workspace folder in hand we can iterate over all literate files in the
workspace and get the fragments for the project. We don't want extrapolated
fragments, we want to see them as they are with fragment usages intact.

``` ts : <<get fragments for hover detection>>=
const diagnostics = vscode.languages.createDiagnosticCollection('literate-completionitems');
const md : MarkdownIt = createMarkdownItParserForLiterate();
let envForCompletion : Array<GrabbedState> = new Array<GrabbedState>();
    new Array<vscode.CompletionItem>();
await iterateLiterateFiles(workspaceFolder, undefined, envForCompletion, md);
let fragments = await handleFragments(workspaceFolder, envForCompletion, diagnostics, false, writeSourceFiles);
```

## Diagnostics

``` ts : <<diagnostic updating>>=
function updateDiagnostics(
  uri: vscode.Uri,
  collection: vscode.DiagnosticCollection,
  diagnostic : vscode.Diagnostic | undefined): void {
  if (uri) {
    if (diagnostic) {
      const diags = Array.from(collection.get(uri) || []);
      diags.push(diagnostic);
      collection.set(uri, diags);
    }
  } else {
    collection.clear();
  }
}

/**
 * Create diagnostic for a given token with message.
 * @param token Token that carries the faulty code fragment
 * @param message Error message
 */
function createErrorDiagnostic(token: Token, message: string) : vscode.Diagnostic {
  let range = fragmentRange(token);
  let diagnostic: vscode.Diagnostic = {
    severity: vscode.DiagnosticSeverity.Error,
    message: message,
    range: range
  };

  return diagnostic;
}

/**
 * Give the location of the line in the Markup document that contains the
 * tag declaration.
 * @param token Token to extract code location from
 */
function locationOfFragment(token: Token): number {
  let linenumber = token.map ? (token.map[0]) : -1;
  return linenumber;
}

/**
 * Give the location of the last line in the Markup document that contains the
 * code fragment.
 * @param token Token to extract code location from
 */
function locationOfFragmentEnd(token: Token): number {
  let linenumber = token.map ? (token.map[1] ) : -1;
  return linenumber;
}


/**
 * Give range for the code fragment, including tag.
 * @param token Token to create range for
 */
function fragmentRange(token: Token): vscode.Range {
  let startTagName = token.info.indexOf("<<") + 2;
  let endTagName = token.info.indexOf(">>") - 1;
  let start = new vscode.Position(locationOfFragment(token), startTagName);
  let end = new vscode.Position(locationOfFragmentEnd(token), endTagName);
  let range: vscode.Range = new vscode.Range(start, end);
  return range;
}
```

## The extension

Our Visual Studio Code entry file is the `extension.ts` file. While developing
the plug-in the JavaScript version created from this, in `out/extension.js` is
set as the entry point for the extension, in `package.json`. But when it is
prepared for release on the Visual Studio Code marketplace this needs to be
changed to the minified and bundled version that gets realized as `out/main.js`.
This ensures, together with a properly set up `.vscodeignore` that the published
package stays small in size. Without that the package is easily over 2MB in
size, but properly configured it is under 400KB.

The extension main entry lies in the activation of the extension, as given by
`<<activate the extension>>`, but before we get there we need to set up several
bits and pieces that are required for the proper functioning of the tools.

First of all we import all the functionality and modules we are going to need.

``` ts : <<literate.*>>= ./src/extension.ts
/* Literate Programming by Nathan 'jesterKing' Letwory */

<<import necessary modules for literate>>
```

After the imports we introduce the `oldFence` where we will keep a hold of the
fence rule from the default *MarkdownIt* parser. I was not entirely sure how to
best tackle it, so for now it is here.

``` ts : <<literate.*>>=+
let oldFence : Renderer.RenderRule | undefined;
```

With that out of the way we introduce the interfaces we use in the Literate
Programming extension.

``` ts : <<literate.*>>=+
<<introduce interfaces>>

```

Next we set up the fragment regular expressions and define everything needed to
implement the fragment explorer. This explorer will show up in the Explorer bar
when a literate project is open. We need a representation for a node in the tree
view, a data provider for the tree view and then the actual tree view explorer
itself.

``` ts : <<literate.*>>=+
<<fragment regular expressions>>

<<fragment node>>

<<fragment tree provider>>

<<fragment explorer>>

<<fragment hover provider>>
```

For our extension we need to override the code fence rule since we want to
augment the rendering of the code fences. Specifically we want to add the
fragment line prior to the code block. This is explained in the section on
`<<renderCodeFence rule>>`.

Also we have a way to create a *MarkdownIt* parser the way we need it. It is
explained in more detail in the section on `<<create markdownit parser>>`.

``` ts : <<literate.*>>=+
<<renderCodeFence rule>>

<<create markdownit parser>>

```

The central mechanism of the **Literate Programming** extension, the tools it
provides, are expressed in `<<render and collect state>>`,
`<<handle fragments>>` and `<<write out source files>>`. These all ensure that
all **literate** files can be iterated, parsed, rendered. And that from the
parsed state all the code fragments can be collected and extrapolated into the
source file or source files as written in the **literate** program.

``` ts : <<literate.*>>=+
<<render and collect state>>
<<handle fragments>>
<<write out source files>>
```

Utility function to determine the workspace folder for a TextDocument

``` ts : <<literate.*>>=+
function determineWorkspaceFolder(document : vscode.TextDocument) : vscode.WorkspaceFolder | undefined
{
  if(!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0)
  {
    return undefined;
  }
  for(const ws of vscode.workspace.workspaceFolders)
  {
    const relativePath = path.relative(ws.uri.toString(), document.uri.toString());
    if(!relativePath.startsWith('..'))
    {
      return ws;
    }
  }
  return undefined;
}
```

Although the fragments mentioned above are the soul of the extension they are
not of much use without the proper activation. With this `activate`
implementation all providers and commands are registered with Visual Studio
Code.

``` ts : <<literate.*>>=+
<<activate the extension>>
```

``` ts : <<literate.*>>=+
<<diagnostic updating>>
```

``` ts : <<literate.*>>=+
export function deactivate() {}
```

### The imports

``` ts : <<import necessary modules for literate>>=
import { TextDecoder } from 'util';
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

import StateCore = require('markdown-it/lib/rules_core/state_core');
import Token = require('markdown-it/lib/token');
import MarkdownIt = require("markdown-it");
import Renderer = require('markdown-it/lib/renderer');

// `import` here fails so instead we require the highlight module
// this way. Not sure why import fails. It would be great to find
// out the reason.
const hljs = require('highlight.js');

import { grabberPlugin } from './grabber';
```

### Interfaces used in Literate Programming

``` ts : <<introduce interfaces>>=
interface WriteRenderCallback {
  (
    fname : string,
    folderUri : vscode.Uri,
    content : string
  ) : Thenable<void>
};
interface WriteSourceCallback {
  (
    workspaceFolder : vscode.WorkspaceFolder,
    fragments : Map<string, FragmentInformation>
  ) : Thenable<void>
};

<<grabbed state type>>
<<fragment information type>>
```

### Extension activation

``` ts : <<activate the extension>>=
export function activate(context: vscode.ExtensionContext) {
  const rootPath = (vscode.workspace.workspaceFolders && (vscode.workspace.workspaceFolders.length > 0))
    ? vscode.workspace.workspaceFolders[0].uri.fsPath : undefined;

  console.log('Ready to do some Literate Programming');
  const diagnostics = vscode.languages.createDiagnosticCollection('literate');

  <<register literate.process>>
  <<register fragment tree view>>
  <<register completion item provider>>

  context.subscriptions.push(
    vscode.languages.registerHoverProvider('markdown', new FragmentHoverProvider())
  );

  if (vscode.window.activeTextEditor) {
    updateDiagnostics(vscode.window.activeTextEditor.document.uri, diagnostics, undefined);
  }
  context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(editor => {
    if (editor) {
      updateDiagnostics(editor.document.uri, diagnostics, undefined);
    }
  }));

  context.subscriptions.push(literateProcessDisposable);
  context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(
    _ => {
      vscode.commands.executeCommand('literate.process');
    }
  ));

  return {
    extendMarkdownIt(md: any) {
      md.use(grabberPlugin);
      oldFence = md.renderer.rules.fence;
      md.renderer.rules.fence = renderCodeFence;
      return md;
    }
  };
};
```

## Afterword

So you have made it this far - or perhaps you just skipped over a lot of text.
If you actually read all the text up to this point you have read also all of the
code for the entire **Literate Programming**. I appreciate you took the time to
read this document. I hope it helped you get more interested in the **literate
programming** paradigm.

I invite you to install the **Literate Programming** extension for Visual Studio
Code and start using it in your daily work.

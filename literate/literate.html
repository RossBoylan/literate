<html>
				<head>
					<link rel="stylesheet" type="text/css" href="./style.css">
				</head>
				<body>
				<h1>Literate Programming</h1>
<h2>The approach</h2>
<p>The main idea of the extension is to collect all fragments that are created in
all <code>.literate</code> files.</p>
<p>Once all fragments have been collected they are expanded such that eventually
there will be only the top fragments. A top fragment specifies a file to which
it will be written.</p>
<p>The first step is to put each <code>.literate</code> file through the <em>MarkdownIt</em> renderer.
Each rendering will be given a special environment that will be used to collect
the state for the render. The state will contain all the tokens as recognized by
the renderer. The state <code>env</code> is of type <code>GrabbedState</code>, and used to collect the
tokens generated by <em>MarkdownIt</em> parser. The tokens are needed to find all the
fragments for our programs. For each <code>.literate</code> file the grabbed state <code>env</code> is
saved in the list of <code>GrabbedState</code>s <code>envList</code>.</p>
<p>Each rendered file will be saved as a <code>HTML</code> file with the same name
as the <code>.literate</code> file that was being rendered, but with the extension replaced
with <code>.html</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;render and collect state&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/** All .literate files found in our workspace */</span>
<span class="hljs-keyword">const</span> foundLiterateFiles = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>
	.<span class="hljs-title function_">findFiles</span>(<span class="hljs-string">&#x27;**/*.literate&#x27;</span>)
	.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file)));

<span class="hljs-comment">// handle all .literate file, extract code and write out.</span>
<span class="hljs-keyword">try</span> {
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fl <span class="hljs-keyword">of</span> foundLiterateFiles) {
		<span class="hljs-keyword">const</span> uri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">file</span>(fl.<span class="hljs-property">path</span>);
		<span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">readFile</span>(uri);
		<span class="hljs-keyword">let</span> fname = fl.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(folderUri.<span class="hljs-property">path</span>, <span class="hljs-string">&#x27;&#x27;</span>);
		<span class="hljs-comment">/** Environment where we can grab the state. */</span>
		<span class="hljs-keyword">const</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span> = { <span class="hljs-attr">literateFileName</span>: fname, <span class="hljs-attr">literateUri</span>: uri, <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, md, {}) };
		<span class="hljs-keyword">const</span> text = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">decode</span>(content);
		envList.<span class="hljs-title function_">push</span>(env);
		<span class="hljs-keyword">const</span> rendered = md.<span class="hljs-title function_">render</span>(text, env);
		<span class="hljs-keyword">const</span> html =
<span class="hljs-string">`&lt;html&gt;
	&lt;head&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;&gt;
	&lt;/head&gt;
	&lt;body&gt;
	<span class="hljs-subst">${rendered}</span>
	&lt;/body&gt;
&lt;/html&gt;`</span>;
		<span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(html, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
		fname = fname.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.literate&quot;</span>, <span class="hljs-string">&quot;.html&quot;</span>);
		<span class="hljs-keyword">const</span> fileUri = folderUri.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">path</span>: posix.<span class="hljs-title function_">join</span>(sourceUri.<span class="hljs-property">path</span>, fname) });
		<span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
	}
} <span class="hljs-keyword">catch</span> (error) {
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);
}
</code></pre>
</div></div><h3>GrabbedState interface</h3>
<p>The <code>GrabbedState</code> interface is used to create a type that helps us collecting
the tokens for each <code>.literate</code> file. Instances of objects with this interface
are passed to a <em>MarkdownIt</em> renderer. The renderer will have the
<code>GrabberPlugin</code> registered. This provides a rule that helps us collecting the
states of each rendered file. The grabbed state is collected in <code>gstate</code>, which
is an instance of the <code>StateCore</code>, provided by <em>MarkdownIt</em>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;grabbed state type&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
 * Interface for environment to hold the Markdown file name and the StateCore
 * grabbed by the grabberPlugin.
 * The gstate we use to access all the tokens generated by the MarkdownIt parser.
 *
 * <span class="hljs-doctag">@see</span> <span class="hljs-variable">StateCore</span>
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">GrabbedState</span> {
	<span class="hljs-comment">/**
	 * File name of the Markdown document to which the state belongs.
	 */</span>
	<span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Uri for the Markdown document.
	 */</span>
	<span class="hljs-attr">literateUri</span>: vscode.<span class="hljs-property">Uri</span>;
	<span class="hljs-comment">/**
	 * State grabbed from the MarkdownIt parser.
	 */</span>
	<span class="hljs-attr">gstate</span>: <span class="hljs-title class_">StateCore</span>;
}
</code></pre>
</div></div><h2>Preparing MarkdownIt</h2>
<p>We set up the <em>MarkdownIt</em> for our purposes. The highlight function we use to
ensure our code fragments get syntax highlighting. This simply relies on
<em>highlight.js</em> to do the work.</p>
<p>We also tell <em>MarkdownIt</em> to use our <code>grabberPlugin</code>. This plug-in harvests the
internal states for each document into instances of <code>GrabbedState</code>. These states
we'll later use to get all the different code fragments and to weave them into
the code files they describe.</p>
<p>Finally we replace the default <code>fence</code> rule with our own <code>renderCodeFence</code> rule.
The intent of that rule will be explained in the section on <code>renderCodeFence</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;set up MarkdownIt&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
	* MarkdownIt instance with grabber_plugin in use.
	*/</span>
<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
		<span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, lang: <span class="hljs-built_in">string</span>, attrs: <span class="hljs-built_in">string</span></span>) {
			<span class="hljs-keyword">if</span>(lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
				<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&lt;code&gt;&#x27;</span> +
				hljs.<span class="hljs-title function_">highlight</span>(str, {language : lang}).<span class="hljs-property">value</span> +
				<span class="hljs-string">&#x27;&lt;/code&gt;&lt;/pre&gt;&#x27;</span>;
			}
			<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre title=&quot;&#x27;</span> + attrs + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span> + md.<span class="hljs-property">utils</span>.escapeHtml(str) + <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>;
		}

	})
	.<span class="hljs-title function_">use</span>(grabberPlugin);

oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
</code></pre>
</div></div><h2>Fragment structure and regular expressions</h2>
<p>Before we dive deeper into the processing of <code>.literate</code> documents it is
necessary to have a look at how fragments work.</p>
<p>Fragments in the <code>literate</code> extension have a specific format that requires a bit
of explaining.</p>
<p>There are four types of fragment tags, three of which either create or modify a
fragment, and one that expresses fragment usage.</p>
<p>For the detection of fragments a couple of regular expressions are used. These
are explained in more detail below.</p>
<h3>Fragment use in code</h3>
<p>Lets start by looking at the form for fragment tag use.</p>
<p>Fragments can be used in code blocks by using their tag double opening and
closing chevrons around the fragment name <code>&lt;&lt;fragment name&gt;&gt;</code>. To detect usage
of fragments in code we use <code>FRAGMENT_USE_IN_CODE_RE</code>.</p>
<p>The regular expression captures four groups. A match will give us 5 or more
results, the whole string matched and the groups. There may be some additional
parts after that, but those we will discard. The whole string matched is called
the <code>tag</code>. The first group is called <code>indent</code>, which will be used to indent the
whole fragment code when it gets extrapolated into the final code. The second
group is called <code>tagName</code>, which is the fragment name. The third group is called
<code>root</code> and the final group is called <code>add</code>. For fragment use we essentially need
only the second group <code>tagName</code>, with the <code>indent</code> still serving a function. The
other groups are in the regular expression so we can identify incorrect use of
fragments in code: creating or adding to fragments inside code blocks is not
valid.</p>
<p>The application of <code>FRAGMENT_USE_IN_CODE_RE</code> is explained in more detail in the
section on code realization.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment regular expressions&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">//let HTML_ENCODED_FRAGMENT_TAG_RE = /(&amp;lt;&amp;lt.*?&amp;gt;&amp;gt;)/g;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span> = <span class="hljs-regexp">/([ \t]*)&lt;&lt;(.*)&gt;&gt;(=)?(\+)?/g</span>;
</code></pre>
</div></div><h3>Creating and modifying fragments</h3>
<p>There is the tag used to create a new fragment, which is always in conjunction
with the opening code fence tag. This means either a triple backtick or triple
tilde followed by the programming language identifier for the following code
block. The actual fragment tag is placed as first option right after the color
following the language specifier.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment regular expressions&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_RE</span> = <span class="hljs-regexp">/(.*):.*&lt;&lt;(.*)&gt;&gt;(=)?(\+)?\s*(.*)/</span>;
</code></pre>
</div></div><p>Most of the groups correspond to the ones defined by <code>FRAGMENT_USE_IN_CODE_RE</code>
with a few additions. Most notably there is the group catching the language
specifier, and the group to catch the filename, called <code>lang</code> and <code>fileName</code>
respectively.</p>
<p>So to create a new tag the info line for the code fence could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=</code>.</p>
<p>To add to a fragment a <code>+</code> is added, so it could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=+</code>. Having a fragment without <code>=</code> or <code>=+</code> on the code
fence info line is an error.</p>
<h2>Gathering all fragments</h2>
<p>All code fragments are fetched from each environment state. This is done through
looking for all <code>fence</code> tokens. If the <code>token.info</code> for a <code>fence</code> matches the
<code>FRAGMENT_RE</code> we can check to see whether the fragment we have currently in our
hands is a new fragment (<code>root &amp;&amp; !add</code>) or whether this one expands an existing
one (<code>root &amp;&amp; add</code>), as will be explained in more detail further down.</p>
<h3>Populating the fragment map</h3>
<p>First we build a map of all available fragments. These will go into <code>fragments</code>,
which is of type <code>Map&lt;string, FragmentInformation&gt;</code>. The name of a fragment will
function as the key, and an instance of <code>FragmentInformation</code> will be the value.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;build fragment map&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
 * Map of fragment names and tuples of code fragments for these. The
 * tuples contain code language identifier followed by the filename and
 * lastly followed by the actual code fragment.
 */</span>
<span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;();
<span class="hljs-comment">// Now we have the state, we have access to the tokens</span>
<span class="hljs-comment">// over which we can iterate to extract all the code</span>
<span class="hljs-comment">// fragments and build up the map with the fragments concatenated</span>
<span class="hljs-comment">// where necessary. We&#x27;ll extrapolate all fragments in the second</span>
<span class="hljs-comment">// pass.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> env <span class="hljs-keyword">of</span> envList) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> token <span class="hljs-keyword">of</span> env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>) {
        &lt;&lt;handle fence tokens&gt;&gt;
    }
}
</code></pre>
</div></div><p>Each <code>fence</code> token we find we need to check. There may be of course code fences
in the document that do not create or modify a fragment. These we need to skip.</p>
<p>Since we are handling code fences we use <code>FRAGMENT_RE</code> to match <code>token.info</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;handle fence tokens&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span>) {
	<span class="hljs-keyword">const</span> linenumber = <span class="hljs-title function_">locationOfFragment</span>(token);
	<span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
	<span class="hljs-keyword">if</span> (match) {
		<span class="hljs-keyword">let</span> [_, lang, name, root, add, fileName, ...__] = match;
		lang = lang.<span class="hljs-title function_">trim</span>();
		&lt;&lt;add to existing fragment&gt;&gt;
		&lt;&lt;create a <span class="hljs-keyword">new</span> fragment&gt;&gt;
	}
}
</code></pre>
</div></div><h3>Creating a new fragment</h3>
<p>If the <code>root</code> group has captured a result, but the <code>add</code> group not we know we
have a new fragment on our hand.</p>
<p>If we already have in our <code>fragments</code> map a key with the same <code>name</code> as the
fragment we are currently handling we add an error diagnostic message. We don't
stop handling fences, or the entire <code>literate.process</code> command for that matter.
We keep on going, but leave it up to the programmer to see and handle the error
messages.</p>
<p>If a fragment name with <code>.*</code> is found we need to ensure there is a result in the
<code>fileName</code> capture group. That is going to be needed to write out the source
code file eventually. A file defining fragment without a file name is an error.</p>
<p>When everything appears to be in order a new <code>FragmentInformation</code> instance is
created with the information found. The code for this fragment is the token
content in <code>token.content</code>. Finally the new <code>FragmentInformation</code> instance is
added to the <code>fragments</code> map.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;create a new fragment&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; !add) {
	<span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
		<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to overwrite existing fragment fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span><span class="hljs-subst">${linenumber}</span>`</span>;
		<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
		<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (!fileName &amp;&amp; name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt; -<span class="hljs-number">1</span>) {
			<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Expected filename for star fragment <span class="hljs-subst">${name}</span>`</span>;
			<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
			<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">let</span> code = token.<span class="hljs-property">content</span>;
			<span class="hljs-keyword">let</span> <span class="hljs-attr">fragmentInfo</span>: <span class="hljs-title class_">FragmentInformation</span> = {
				<span class="hljs-attr">lang</span>: lang,
				<span class="hljs-attr">literateFileName</span>: env.<span class="hljs-property">literateFileName</span>,
				<span class="hljs-attr">sourceFileName</span>: fileName,
				<span class="hljs-attr">code</span>: code,
				<span class="hljs-attr">tokens</span>: [token],
				<span class="hljs-attr">env</span>: env,
			};
			fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
		}
	}
}
</code></pre>
</div></div><h3>Modifying an exiting fragment</h3>
<p>If both the <code>root</code> and <code>add</code> groups have capture their results, an <code>=</code> and an
<code>+</code> respectively we need to add code to an existing fragment.</p>
<p>For this to work a new fragment needs to be always present before the modifying
fragment. It is an error to try to modify a fragment that hasn't been seen yet.</p>
<p>The fragment with specified <code>name</code> is fetched, and when it is not <code>undefined</code>
the <code>token.content</code> is appended to the <code>code</code> of the <code>FragmentInformation</code>
instance we got from the map. The current token is also appended to the <code>tokens</code>
list.</p>
<p>The fragments map is updated with the modified  <code>FragmentInformation</code> instance.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;add to existing fragment&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; add) {
	<span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
		<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
		<span class="hljs-keyword">if</span>(fragmentInfo &amp;&amp; fragmentInfo.<span class="hljs-property">code</span>) {
			<span class="hljs-keyword">let</span> additionalCode = token.<span class="hljs-property">content</span>;
			fragmentInfo.<span class="hljs-property">code</span> = <span class="hljs-string">`<span class="hljs-subst">${fragmentInfo.code}</span><span class="hljs-subst">${additionalCode}</span>`</span>;
			fragmentInfo.<span class="hljs-property">tokens</span>.<span class="hljs-title function_">push</span>(token);
			fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to add to non-existant fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span>:<span class="hljs-subst">${linenumber}</span>`</span>;
		<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
		<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
	}
}
</code></pre>
</div></div><h3>The FragmentInformation type</h3>
<p>We have now seen the <code>FragmentInformation</code> type being used several times, so it
is important to take a moment to clarify it in more detail.</p>
<p>The interface allows us to gather information for each found code fragment. It
allows us to store the programming language identifier, name of the <code>.literate</code>
file and name of the targeted source file, if the code fragment happens to be a
top fragment.</p>
<p>The actual code for the fragment is stored in <code>code</code>. Furthermore the tokens for
the complete fragment are stored in the <code>tokens</code> list. This list is of objects
that fullfill the <code>Token</code> interface, which is provided by the <em>MarkdownIt</em>
module.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment information type&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
 * Interface denoting a fragment and related information
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FragmentInformation</span> {
	<span class="hljs-comment">/**
	 * Programming language identifier for fragment.
	 */</span>
	<span class="hljs-attr">lang</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Filename of literate file.
	 */</span>
	<span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Filename of target source file. This is set when the fragment
	 * is a top fragment.
	 */</span>
	<span class="hljs-attr">sourceFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * The code fragment.
	 */</span>
	<span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * List of tokens that make up the entire code fragment.
	 */</span>
	<span class="hljs-attr">tokens</span>: <span class="hljs-title class_">Token</span>[];
	<span class="hljs-comment">/**
	 * The GrabbedState related to this fragment.
	 */</span>
	<span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span>;
}
</code></pre>
</div></div><h2>Extrapolating fragments</h2>
<p>Once all fragments have been collected from the <code>.literate</code> files of the project
fragments can be combined into source code.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;extrapolate fragments&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">// for now do several passes</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pass</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">do</span> {
	pass++;
	<span class="hljs-keyword">let</span> fragmentReplaced = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
		<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
		<span class="hljs-keyword">if</span> (!fragmentInfo) {
			<span class="hljs-keyword">continue</span>;
		}

		<span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
			<span class="hljs-keyword">let</span> [tag, indent, tagName, root, add, ...rest] = match;
			<span class="hljs-keyword">if</span> (root) {
				<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;=&#x27;: incorrect fragment tag in fragment, <span class="hljs-subst">${tag}</span>`</span>;
				<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
				<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
			}
			<span class="hljs-keyword">if</span> (add) {
				<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;+&#x27;: incorrect fragment tag in fragment: <span class="hljs-subst">${tag}</span>`</span>;
				<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
				<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
			}
			<span class="hljs-keyword">if</span> (!fragments.<span class="hljs-title function_">has</span>(tagName) &amp;&amp; tagName !== <span class="hljs-string">&quot;(.*)&quot;</span>) {
				<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Could not find fragment <span class="hljs-subst">${tag}</span> (<span class="hljs-subst">${tagName}</span>)`</span>;
				<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
				<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
			}
			<span class="hljs-keyword">let</span> fragmentToReplaceWith = fragments.<span class="hljs-title function_">get</span>(tagName) || <span class="hljs-literal">undefined</span>;
			<span class="hljs-keyword">if</span> (fragmentToReplaceWith) {
				<span class="hljs-keyword">let</span> code = fragmentToReplaceWith.<span class="hljs-property">code</span>;
				<span class="hljs-keyword">let</span> lines = code.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
				<span class="hljs-keyword">let</span> indentedLines = lines.<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e, _</span>) {
					<span class="hljs-keyword">return</span> indent + e;

				});
				<span class="hljs-keyword">let</span> newcode = indentedLines.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
				fragmentReplaced = <span class="hljs-literal">true</span>;
				fragmentInfo.<span class="hljs-property">code</span> = fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">replace</span>(tag, newcode);
				fragments.<span class="hljs-title function_">set</span>(fragmentName, fragmentInfo);
			}
		}
	}
	<span class="hljs-keyword">if</span>(!fragmentReplaced) {
		<span class="hljs-keyword">break</span>;
	}
}
<span class="hljs-keyword">while</span> (pass &lt; <span class="hljs-number">25</span>);
</code></pre>
</div></div><h2>custom code fence rendering</h2>
<p>Our extension uses a custom code fence rendering rule to ensure the code
fragment name is also rendered as part of the fence.</p>
<p>Essentially the old, default rendering rule for fences is first used to create
the original fence.</p>
<p>Then the <code>token.info</code> is matched against the <code>FRAGMENT_RE</code> regular expression.
If we have a match we prepare the <code>HTML</code> code to essentially wrap around the
<code>HTML</code> as generated by the default rule.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;renderCodeFence rule&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderCodeFence</span>(<span class="hljs-params">tokens : Token[], idx : <span class="hljs-built_in">number</span>, options : MarkdownIt.Options, env : <span class="hljs-built_in">any</span>, slf : Renderer</span>) {
	<span class="hljs-keyword">let</span> rendered = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">if</span> (oldFence) {
		rendered = <span class="hljs-title function_">oldFence</span>(tokens, idx, options, env, slf);

		<span class="hljs-keyword">let</span> token = tokens[idx];
		<span class="hljs-keyword">if</span> (token.<span class="hljs-property">info</span>) {
			<span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
			<span class="hljs-keyword">if</span> (match) {
				<span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/naming-convention</span>
				<span class="hljs-keyword">let</span> [_, lang, name, root, add, __, ...___] = match;
				lang = lang.<span class="hljs-title function_">trim</span>();
				<span class="hljs-keyword">if</span> (name) {
					root = root || <span class="hljs-string">&#x27;&#x27;</span>;
					add = add || <span class="hljs-string">&#x27;&#x27;</span>;
					rendered = <span class="hljs-string">`&lt;div class=&quot;codefragment&quot;&gt;&lt;div class=&quot;fragmentname&quot;&gt;&amp;lt;&amp;lt;<span class="hljs-subst">${name}</span>&amp;gt;&amp;gt;<span class="hljs-subst">${root}</span><span class="hljs-subst">${add}</span>&lt;/div&gt;&lt;div class=&quot;code&quot;&gt;<span class="hljs-subst">${rendered}</span>&lt;/div&gt;&lt;/div&gt;`</span>;
					<span class="hljs-comment">//rendered = rendered.replaceAll(HTML_ENCODED_FRAGMENT_TAG_RE, codeFragmentCleanup);</span>
				}
			}
		}
	}

	<span class="hljs-keyword">return</span> rendered;
};
</code></pre>
</div></div><h2>Register the literate.process command</h2>
<p>The command <code>literate.process</code> is registered with Visual Studio Code. The
disposable that gets returned by <code>registerCommand</code> is held in
<code>literateProcessDisposable</code> so that it can be used later on, for instance for
diagnostics management.</p>
<p>Here we find the main program of our <code>literate.process</code> command. Our
<em>MarkdownIt</em> is set up, <code>.literate</code> files are searched and iterated. Each
<code>.literate</code> file is rendered, and code fragments are harvested. Finally code
fragments are extrapolated and saved to their respective source code files. The
<code>HTML</code> files are also saved to files.</p>
<p>Diagnostic messages are also handled here. Errors and warnings are shown where
necessary. On successfull completion a simple status bar message will be used.
An information diagnostic message is not good here, because that will prevent
the usage of <code>literate.process</code> in for instance <code>tasks.json</code>, since the
diagnostic message will block execution of a task if it were used as prelaunch
task. That is obviously not good for the workflow.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;register literate.process&gt;&gt;=</div><div class="code"><pre><code>	<span class="hljs-comment">// The command has been defined in the package.json file</span>
	<span class="hljs-comment">// Now provide the implementation of the command with registerCommand</span>
	<span class="hljs-comment">// The commandId parameter must match the command field in package.json</span>
	<span class="hljs-keyword">let</span> literateProcessDisposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(<span class="hljs-string">&#x27;literate.process&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {

		&lt;&lt;set up <span class="hljs-title class_">MarkdownIt</span>&gt;&gt;

		diagnostics.<span class="hljs-title function_">clear</span>();

		<span class="hljs-keyword">if</span> (!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>) {
			<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&quot;No workspace or folder opened&quot;</span>);
		}

		<span class="hljs-comment">/**
		 * Contains environments for each Markup document parsed and rendered.
		 */</span>
		<span class="hljs-keyword">const</span> <span class="hljs-attr">envList</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
		<span class="hljs-comment">/**
		 * The URI for the workspace folder that will be searched for .literate
		 * files to generate code and documentation for.
		 */</span>
		<span class="hljs-keyword">const</span> folderUri = vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>[<span class="hljs-number">0</span>].<span class="hljs-property">uri</span>;
		<span class="hljs-comment">/** The Uri for the parent path where generated code is saved. */</span>
		<span class="hljs-keyword">const</span> sourceUri = folderUri;

		<span class="hljs-comment">// ensure the path exists.</span>
		vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">createDirectory</span>(sourceUri);

		&lt;&lt;render and collect state&gt;&gt;

		&lt;&lt;build fragment map&gt;&gt;

		&lt;&lt;extrapolate fragments&gt;&gt;

		<span class="hljs-comment">/* now write out the source files. */</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
			<span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
				<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
				<span class="hljs-keyword">if</span> (fragmentInfo) {
					<span class="hljs-keyword">let</span> fileName = fragmentInfo.<span class="hljs-property">sourceFileName</span>.<span class="hljs-title function_">trim</span>();
					<span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(fragmentInfo.<span class="hljs-property">code</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
					<span class="hljs-keyword">const</span> fileUri = folderUri.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">path</span>: posix.<span class="hljs-title function_">join</span>(sourceUri.<span class="hljs-property">path</span>, fileName) });
					<span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
				}
			}
		}

		<span class="hljs-keyword">let</span> hasAnyDiagnostics = <span class="hljs-literal">false</span>;
		diagnostics.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">_: vscode.Uri, diags: <span class="hljs-keyword">readonly</span> vscode.Diagnostic[], __: vscode.DiagnosticCollection</span>) : <span class="hljs-built_in">any</span> {
			hasAnyDiagnostics ||= (diags.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>);
		}
		);

		<span class="hljs-keyword">if</span> (hasAnyDiagnostics) {
			<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showErrorMessage</span>(<span class="hljs-string">&quot;Error encountered during process&quot;</span>);
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">setStatusBarMessage</span>(<span class="hljs-string">&quot;Literate Process completed&quot;</span>, <span class="hljs-number">5000</span>);
		}
	});
</code></pre>
</div></div><h2>The extension file</h2>
<p>Our Visual Studio Code entry file is the <code>extension.ts</code> file. While developing
the plug-in the JavaScript version created from this, in <code>out/extension.js</code> is
set as the entry point for the extension, in <code>package.json</code>. But when it is
prepared for release on the Visual Studio Code marketplace this needs to be
changed to the minified and bundled version that gets realized as <code>out/main.js</code>.
This ensures, together with a properly set up <code>.vscodeignore</code> that the published
package stays small in size. Without that the package is easily over 2MB in
size, but properly configured it is under 400KB.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">import</span> <span class="hljs-title class_">StateCore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/rules_core/state_core&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Token</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/token&#x27;</span>);
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">TextDecoder</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;util&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> vscode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vscode&#x27;</span>;
<span class="hljs-keyword">import</span> { posix } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;

<span class="hljs-comment">// `import` here fails so instead we require the highlight module</span>
<span class="hljs-comment">// this way. Not sure why import fails. It would be great to find</span>
<span class="hljs-comment">// out the reason.</span>
<span class="hljs-keyword">const</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;highlight.js&#x27;</span>);

<span class="hljs-keyword">import</span> { grabberPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./grabber&#x27;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;markdown-it&quot;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Renderer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/renderer&#x27;</span>);

&lt;&lt;grabbed state <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;fragment information <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;fragment regular expressions&gt;&gt;

<span class="hljs-keyword">let</span> oldFence : <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">RenderRule</span> | <span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>) {
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ready to do some Literate Programming&#x27;</span>);
	<span class="hljs-keyword">const</span> diagnostics = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate&#x27;</span>);
	<span class="hljs-comment">//setupLanguageMapping();</span>

	&lt;&lt;register literate.<span class="hljs-property">process</span>&gt;&gt;

	<span class="hljs-keyword">if</span> (vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>) {
		<span class="hljs-title function_">updateDiagnostics</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
	}
	context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">onDidChangeActiveTextEditor</span>(<span class="hljs-function"><span class="hljs-params">editor</span> =&gt;</span> {
		<span class="hljs-keyword">if</span> (editor) {
			<span class="hljs-title function_">updateDiagnostics</span>(editor.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
		}
	}));

	context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(literateProcessDisposable);

	<span class="hljs-keyword">return</span> {
		<span class="hljs-title function_">extendMarkdownIt</span>(<span class="hljs-params">md: <span class="hljs-built_in">any</span></span>) {
			md.<span class="hljs-title function_">use</span>(grabberPlugin);
			oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
			md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
			<span class="hljs-keyword">return</span> md;
		}
	};
};

<span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/naming-convention</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">codeFragmentCleanup</span>(<span class="hljs-params">_: <span class="hljs-built_in">string</span>, p1 : <span class="hljs-built_in">string</span>, __: <span class="hljs-built_in">number</span>, ___: <span class="hljs-built_in">string</span></span>) {
	<span class="hljs-keyword">let</span> cleaned = p1.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/&lt;.*?&gt;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;span class=&quot;fragmentuse&quot;&gt;<span class="hljs-subst">${cleaned}</span>&lt;/span&gt;`</span>;
}

&lt;&lt;renderCodeFence rule&gt;&gt;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDiagnostics</span>(<span class="hljs-params">uri: vscode.Uri, collection: vscode.DiagnosticCollection, diagnostic : vscode.Diagnostic | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">void</span> {
	<span class="hljs-keyword">if</span> (uri) {
		<span class="hljs-keyword">if</span> (diagnostic) {
			<span class="hljs-keyword">const</span> diags = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(collection.<span class="hljs-title function_">get</span>(uri) || []);
			diags.<span class="hljs-title function_">push</span>(diagnostic);
			collection.<span class="hljs-title function_">set</span>(uri, diags);
		}
	} <span class="hljs-keyword">else</span> {
		collection.<span class="hljs-title function_">clear</span>();
	}
}

<span class="hljs-comment">/**
 * Create diagnostic for a given token with message.
 * <span class="hljs-doctag">@param</span> token Token that carries the faulty code fragment
 * <span class="hljs-doctag">@param</span> message Error message
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createErrorDiagnostic</span>(<span class="hljs-params">token: Token, message: <span class="hljs-built_in">string</span></span>) : vscode.<span class="hljs-property">Diagnostic</span> {
	<span class="hljs-keyword">let</span> range = <span class="hljs-title function_">fragmentRange</span>(token);
	<span class="hljs-keyword">let</span> <span class="hljs-attr">diagnostic</span>: vscode.<span class="hljs-property">Diagnostic</span> = {
		<span class="hljs-attr">severity</span>: vscode.<span class="hljs-property">DiagnosticSeverity</span>.<span class="hljs-property">Error</span>,
		<span class="hljs-attr">message</span>: message,
		<span class="hljs-attr">range</span>: range
	};

	<span class="hljs-keyword">return</span> diagnostic;
}

<span class="hljs-comment">/**
 * Give the location of the line in the Markup document that contains the
 * tag declaration.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragment</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
	<span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>]) : -<span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> linenumber;
}

<span class="hljs-comment">/**
 * Give the location of the last line in the Markup document that contains the
 * code fragment.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragmentEnd</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
	<span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>] ) : -<span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> linenumber;
}


<span class="hljs-comment">/**
 * Give range for the code fragment, including tag.
 * <span class="hljs-doctag">@param</span> token Token to create range for
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fragmentRange</span>(<span class="hljs-params">token: Token</span>): vscode.<span class="hljs-property">Range</span> {
	<span class="hljs-keyword">let</span> startTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>) + <span class="hljs-number">2</span>;
	<span class="hljs-keyword">let</span> endTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>) - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragment</span>(token), startTagName);
	<span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragmentEnd</span>(token), endTagName);
	<span class="hljs-keyword">let</span> <span class="hljs-attr">range</span>: vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(start, end);
	<span class="hljs-keyword">return</span> range;
}

<span class="hljs-comment">/*
let languageMapping = new Map&lt;string, string&gt;();
function setupLanguageMapping() {
	languageMapping.set(&quot;csharp&quot;, &quot;cs&quot;);
}

function extensionForLanguage(lang: string): string
{
	lang = lang.trim();
	if (lang.length &lt;= 2) {
		return lang;
	}

	if (languageMapping.has(lang)) {
		let extension = languageMapping.get(lang);
		if (extension) {
			return extension;
		}
	}

	return &#x27;xx&#x27;;
}

*/</span>

<span class="hljs-comment">// this method is called when your extension is deactivated</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deactivate</span>(<span class="hljs-params"></span>) {}

</code></pre>
</div></div>
				</body>
			</html>
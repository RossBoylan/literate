<html>
	<head>
		<link rel="stylesheet" type="text/css" href="./style.css">
	</head>
	<body>
	<h1>Literate Programming</h1>
<p>The main idea of the extension is to collect all fragments that are
created in all <code>.literate</code> files.</p>
<p>All the fragments are expanded such that eventually there will be
only the top fragments. A top fragment specifies a file to which
it will be written.</p>
<p>The first step is to put each <code>.literate</code> file through the MarkdownIt
renderer. Each rendering will be given a special environment that will
be used to collect the state for the render. The state will contain all
the tokens as recognized by the renderer.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;render and collect state&gt;&gt;=</div><div class="code"><pre><code>		<span class="hljs-comment">// handle all .literate file, extract code and write out.</span>
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fl <span class="hljs-keyword">of</span> foundLiterateFiles) {
				<span class="hljs-keyword">const</span> uri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">file</span>(fl.<span class="hljs-property">path</span>);
				<span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">readFile</span>(uri);
				<span class="hljs-keyword">let</span> fname = fl.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(folderUri.<span class="hljs-property">path</span>, <span class="hljs-string">&#x27;&#x27;</span>);
				<span class="hljs-comment">/** Environment where we can grab the state. */</span>
				<span class="hljs-keyword">const</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span> = { <span class="hljs-attr">literateFileName</span>: fname, <span class="hljs-attr">literateUri</span>: uri, <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, md, {}) };
				<span class="hljs-keyword">const</span> text = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">decode</span>(content);
				envList.<span class="hljs-title function_">push</span>(env);
				<span class="hljs-keyword">const</span> rendered = md.<span class="hljs-title function_">render</span>(text, env);
				<span class="hljs-keyword">const</span> html =
<span class="hljs-string">`&lt;html&gt;
	&lt;head&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;&gt;
	&lt;/head&gt;
	&lt;body&gt;
	<span class="hljs-subst">${rendered}</span>
	&lt;/body&gt;
&lt;/html&gt;`</span>;
				<span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(html, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
				fname = fname.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.literate&quot;</span>, <span class="hljs-string">&quot;.html&quot;</span>);
				<span class="hljs-keyword">const</span> fileUri = folderUri.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">path</span>: posix.<span class="hljs-title function_">join</span>(sourceUri.<span class="hljs-property">path</span>, fname) });
				<span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
			}
		} <span class="hljs-keyword">catch</span> (error) {
			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);
		}
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">import</span> <span class="hljs-title class_">StateCore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/rules_core/state_core&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Token</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/token&#x27;</span>);
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">TextDecoder</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;util&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> vscode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vscode&#x27;</span>;
<span class="hljs-keyword">import</span> { posix } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;

<span class="hljs-comment">// `import` here fails so instead we require the highlight module</span>
<span class="hljs-comment">// this way. Not sure why import fails. It would be great to find</span>
<span class="hljs-comment">// out the reason.</span>
<span class="hljs-keyword">const</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;highlight.js&#x27;</span>);

<span class="hljs-keyword">import</span> { grabberPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./grabber&#x27;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;markdown-it&quot;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Renderer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/renderer&#x27;</span>);


<span class="hljs-comment">/**
 * Interface for environment to hold the Markdown file name and the StateCore
 * grabbed by the grabberPlugin.
 * The gstate we use to access all the tokens generated by the MarkdownIt parser.
 *
 * <span class="hljs-doctag">@see</span> <span class="hljs-variable">StateCore</span>
 */</span>
<span class="hljs-keyword">interface</span> GrabbedState {
	<span class="hljs-comment">/**
	 * File name of the Markdown document to which the state belongs.
	 */</span>
	<span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Uri for the Markdown document.
	 */</span>
	<span class="hljs-attr">literateUri</span>: vscode.<span class="hljs-property">Uri</span>;
	<span class="hljs-comment">/**
	 * State grabbed from the MarkdownIt parser.
	 */</span>
	<span class="hljs-attr">gstate</span>: <span class="hljs-title class_">StateCore</span>;
}

<span class="hljs-comment">/**
 * Interface denoting a fragment and related information
 */</span>
<span class="hljs-keyword">interface</span> FragmentInformation {
	<span class="hljs-attr">lang</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-attr">sourceFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-attr">tokens</span>: <span class="hljs-title class_">Token</span>[];
	<span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span>;
}

<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_RE</span> = <span class="hljs-regexp">/(.*):.*&lt;&lt;(.*)&gt;&gt;(=)?(\+)?\s*(.*)/</span>;
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENTS_RE</span> = <span class="hljs-regexp">/([ \t]*)&lt;&lt;(.*)&gt;&gt;(=)?(\+)?/g</span>;
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_IN_CODE</span> = <span class="hljs-regexp">/(&amp;lt;&amp;lt.*?&amp;gt;&amp;gt;)/g</span>;
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">CLEAN_FRAGMENT_IN_CODE</span> = <span class="hljs-regexp">/(&amp;lt;&amp;lt.*?&amp;gt;&amp;gt;)/g</span>;
<span class="hljs-keyword">let</span> oldFence : <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">RenderRule</span> | <span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>) {
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ready to do some Literate Programming&#x27;</span>);
	<span class="hljs-keyword">const</span> diagnostics = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate&#x27;</span>);
	<span class="hljs-comment">//setupLanguageMapping();</span>

	<span class="hljs-comment">// The command has been defined in the package.json file</span>
	<span class="hljs-comment">// Now provide the implementation of the command with registerCommand</span>
	<span class="hljs-comment">// The commandId parameter must match the command field in package.json</span>
	<span class="hljs-keyword">let</span> disposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(<span class="hljs-string">&#x27;literate.process&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
		<span class="hljs-comment">/**
		 * MarkdownIt instance with grabber_plugin in use.
		 */</span>
		<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
				<span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, lang: <span class="hljs-built_in">string</span>, attrs: <span class="hljs-built_in">string</span></span>) {
					<span class="hljs-keyword">if</span>(lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
						<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&lt;code&gt;&#x27;</span> +
						hljs.<span class="hljs-title function_">highlight</span>(str, {language : lang}).<span class="hljs-property">value</span> +
						<span class="hljs-string">&#x27;&lt;/code&gt;&lt;/pre&gt;&#x27;</span>;
					}
					<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre title=&quot;&#x27;</span> + attrs + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span> + md.<span class="hljs-property">utils</span>.escapeHtml(str) + <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>;
				}

			})
			.<span class="hljs-title function_">use</span>(grabberPlugin);

		oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
		md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;

		diagnostics.<span class="hljs-title function_">clear</span>();

		<span class="hljs-keyword">if</span> (!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>) {
			<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&quot;No workspace or folder opened&quot;</span>);
		}

		<span class="hljs-comment">/**
		 * Contains environments for each Markup document parsed and rendered.
		 */</span>
		<span class="hljs-keyword">const</span> <span class="hljs-attr">envList</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
		<span class="hljs-comment">/**
		 * The URI for the workspace folder that will be searched for .literate
		 * files to generate code and documentation for.
		 */</span>
		<span class="hljs-keyword">const</span> folderUri = vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>[<span class="hljs-number">0</span>].<span class="hljs-property">uri</span>;
		<span class="hljs-comment">/** The Uri for the parent path where generated code is saved. */</span>
		<span class="hljs-keyword">const</span> sourceUri = folderUri;

		<span class="hljs-comment">// ensure the path exists.</span>
		vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">createDirectory</span>(sourceUri);

		<span class="hljs-comment">/** All .literate files found in our workspace */</span>
		<span class="hljs-keyword">const</span> foundLiterateFiles = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>
			.<span class="hljs-title function_">findFiles</span>(<span class="hljs-string">&#x27;**/*.literate&#x27;</span>)
			.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file)));

        &lt;&lt;render and collect state&gt;&gt;
		<span class="hljs-comment">/**
		 * Map of fragment names and tuples of code fragments for these. The
		 * tuples contain code language identifier followed by the filename and
		 * lastly followed by the actual code fragment.
		 */</span>
		<span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;();
		<span class="hljs-comment">// Now we have the state, we have access to the tokens</span>
		<span class="hljs-comment">// over which we can iterate to extract all the code</span>
		<span class="hljs-comment">// fragments and build up the map with the fragments concatenated</span>
		<span class="hljs-comment">// where necessary. We&#x27;ll extrapolate all fragments in the second</span>
		<span class="hljs-comment">// pass.</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> env <span class="hljs-keyword">of</span> envList) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> token <span class="hljs-keyword">of</span> env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>) {
				<span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span>) {
					<span class="hljs-keyword">const</span> linenumber = <span class="hljs-title function_">locationOfFragment</span>(token);
					<span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
					<span class="hljs-keyword">if</span> (match) {
						<span class="hljs-keyword">let</span> [_, lang, name, root, add, fileName, ...__] = match;
						lang = lang.<span class="hljs-title function_">trim</span>();
						<span class="hljs-comment">// =+ in the fragment name, we&#x27;re adding to an existing fragment</span>
						<span class="hljs-keyword">if</span> (root &amp;&amp; add) {
							<span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
								<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
								<span class="hljs-keyword">if</span>(fragmentInfo &amp;&amp; fragmentInfo.<span class="hljs-property">code</span>) {
									<span class="hljs-keyword">let</span> additionalCode = <span class="hljs-title function_">decorateCodeWithLine</span>(token, env);
									fragmentInfo.<span class="hljs-property">code</span> =
<span class="hljs-string">`<span class="hljs-subst">${fragmentInfo.code}</span>
<span class="hljs-subst">${additionalCode}</span>`</span>;
									fragmentInfo.<span class="hljs-property">tokens</span>.<span class="hljs-title function_">push</span>(token);
									fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
								}
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to add to non-existant fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span>:<span class="hljs-subst">${linenumber}</span>`</span>;
								<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
								<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
							}
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root &amp;&amp; !add) {
							<span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
								<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to overwrite existing fragment fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span><span class="hljs-subst">${linenumber}</span>`</span>;
								<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
								<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">if</span> (!fileName &amp;&amp; name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;*&quot;</span>) &gt; -<span class="hljs-number">1</span>) {
									<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Expected filename for star fragment <span class="hljs-subst">${name}</span>`</span>;
									<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
									<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">let</span> code = <span class="hljs-title function_">decorateCodeWithLine</span>(token, env);
									<span class="hljs-keyword">let</span> <span class="hljs-attr">fragmentInfo</span>: <span class="hljs-title class_">FragmentInformation</span> = {
										<span class="hljs-attr">lang</span>: lang,
										<span class="hljs-attr">literateFileName</span>: env.<span class="hljs-property">literateFileName</span>,
										<span class="hljs-attr">sourceFileName</span>: fileName,
										<span class="hljs-attr">code</span>: code,
										<span class="hljs-attr">tokens</span>: [token],
										<span class="hljs-attr">env</span>: env,
									};
									fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
								}
							}
						}
					}
				}
			}
		}

		<span class="hljs-comment">// for now do several passes</span>
		<span class="hljs-keyword">let</span> <span class="hljs-attr">pass</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">do</span> {
			pass++;
			<span class="hljs-keyword">let</span> fragmentReplaced = <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
				<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
				<span class="hljs-keyword">if</span> (!fragmentInfo) {
					<span class="hljs-keyword">continue</span>;
				}

				<span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENTS_RE</span>)];
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
					<span class="hljs-keyword">let</span> [tag, indent, tagName, root, add, ...rest] = match;
					<span class="hljs-keyword">if</span> (root) {
						<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;=&#x27;: incorrect fragment tag in fragment, <span class="hljs-subst">${tag}</span>`</span>;
						<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
						<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
					}
					<span class="hljs-keyword">if</span> (add) {
						<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;+&#x27;: incorrect fragment tag in fragment: <span class="hljs-subst">${tag}</span>`</span>;
						<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
						<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
					}
					<span class="hljs-keyword">if</span> (!fragments.<span class="hljs-title function_">has</span>(tagName)) {
						<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`could not find fragment <span class="hljs-subst">${tag}</span> (<span class="hljs-subst">${tagName}</span>)`</span>;
						<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
						<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
					}
					<span class="hljs-keyword">let</span> fragmentToReplaceWith = fragments.<span class="hljs-title function_">get</span>(tagName) || <span class="hljs-literal">undefined</span>;
					<span class="hljs-keyword">if</span> (fragmentToReplaceWith) {
						<span class="hljs-keyword">let</span> code = fragmentToReplaceWith.<span class="hljs-property">code</span>;
						<span class="hljs-keyword">let</span> lines = code.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
						<span class="hljs-keyword">let</span> indentedLines = lines.<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e, _</span>) {
							<span class="hljs-keyword">return</span> indent + e;

						});
						<span class="hljs-keyword">let</span> newcode = indentedLines.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
						fragmentReplaced = <span class="hljs-literal">true</span>;
						fragmentInfo.<span class="hljs-property">code</span> = fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">replace</span>(tag, newcode);
						fragments.<span class="hljs-title function_">set</span>(fragmentName, fragmentInfo);
					}
				}
			}
			<span class="hljs-keyword">if</span>(!fragmentReplaced) {
				<span class="hljs-keyword">break</span>;
			}
		}
		<span class="hljs-keyword">while</span> (pass &lt; <span class="hljs-number">25</span>);

		<span class="hljs-comment">/* now write out the source files. */</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
			<span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
				<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
				<span class="hljs-keyword">if</span> (fragmentInfo) {
					<span class="hljs-keyword">let</span> fileName = fragmentInfo.<span class="hljs-property">sourceFileName</span>.<span class="hljs-title function_">trim</span>();
					<span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(fragmentInfo.<span class="hljs-property">code</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
					<span class="hljs-keyword">const</span> fileUri = folderUri.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">path</span>: posix.<span class="hljs-title function_">join</span>(sourceUri.<span class="hljs-property">path</span>, fileName) });
					<span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
				}
			}
		}

		<span class="hljs-keyword">let</span> hasAnyDiagnostics = <span class="hljs-literal">false</span>;
		diagnostics.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">_: vscode.Uri, diags: <span class="hljs-keyword">readonly</span> vscode.Diagnostic[], __: vscode.DiagnosticCollection</span>) : <span class="hljs-built_in">any</span> {
			hasAnyDiagnostics ||= (diags.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>);
		}
		);

		<span class="hljs-keyword">if</span> (hasAnyDiagnostics) {
			<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showErrorMessage</span>(<span class="hljs-string">&quot;Error encountered during process&quot;</span>);
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&quot;Process completed&quot;</span>);
		}
	});

	<span class="hljs-keyword">if</span> (vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>) {
		<span class="hljs-title function_">updateDiagnostics</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
	}
	context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">onDidChangeActiveTextEditor</span>(<span class="hljs-function"><span class="hljs-params">editor</span> =&gt;</span> {
		<span class="hljs-keyword">if</span> (editor) {
			<span class="hljs-title function_">updateDiagnostics</span>(editor.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
		}
	}));
	context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(disposable);

	<span class="hljs-keyword">return</span> {
		<span class="hljs-title function_">extendMarkdownIt</span>(<span class="hljs-params">md: <span class="hljs-built_in">any</span></span>) {
			md.<span class="hljs-title function_">use</span>(grabberPlugin);
			oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
			md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
			<span class="hljs-keyword">return</span> md;
		}
	};
};

<span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/naming-convention</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">codeFragmentCleanup</span>(<span class="hljs-params">_: <span class="hljs-built_in">string</span>, p1 : <span class="hljs-built_in">string</span>, __: <span class="hljs-built_in">number</span>, ___: <span class="hljs-built_in">string</span></span>) {
	<span class="hljs-keyword">let</span> cleaned = p1.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/&lt;.*?&gt;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;span class=&quot;fragmentuse&quot;&gt;<span class="hljs-subst">${cleaned}</span>&lt;/span&gt;`</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderCodeFence</span>(<span class="hljs-params">tokens : Token[], idx : <span class="hljs-built_in">number</span>, options : MarkdownIt.Options, env : <span class="hljs-built_in">any</span>, slf : Renderer</span>) {
	<span class="hljs-keyword">let</span> rendered = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">if</span> (oldFence) {
		rendered = <span class="hljs-title function_">oldFence</span>(tokens, idx, options, env, slf);

		<span class="hljs-keyword">let</span> token = tokens[idx];
		<span class="hljs-keyword">if</span> (token.<span class="hljs-property">info</span>) {
			<span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
			<span class="hljs-keyword">if</span> (match) {
				<span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/naming-convention</span>
				<span class="hljs-keyword">let</span> [_, lang, name, root, add, __, ...___] = match;
				lang = lang.<span class="hljs-title function_">trim</span>();
				<span class="hljs-keyword">if</span> (name) {
					root = root || <span class="hljs-string">&#x27;&#x27;</span>;
					add = add || <span class="hljs-string">&#x27;&#x27;</span>;
					rendered = <span class="hljs-string">`&lt;div class=&quot;codefragment&quot;&gt;&lt;div class=&quot;fragmentname&quot;&gt;&amp;lt;&amp;lt;<span class="hljs-subst">${name}</span>&amp;gt;&amp;gt;<span class="hljs-subst">${root}</span><span class="hljs-subst">${add}</span>&lt;/div&gt;&lt;div class=&quot;code&quot;&gt;<span class="hljs-subst">${rendered}</span>&lt;/div&gt;&lt;/div&gt;`</span>;
					<span class="hljs-comment">//rendered = rendered.replaceAll(FRAGMENT_IN_CODE, codeFragmentCleanup);</span>
				}
			}
		}
	}

	<span class="hljs-keyword">return</span> rendered;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDiagnostics</span>(<span class="hljs-params">uri: vscode.Uri, collection: vscode.DiagnosticCollection, diagnostic : vscode.Diagnostic | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">void</span> {
	<span class="hljs-keyword">if</span> (uri) {
		<span class="hljs-keyword">if</span> (diagnostic) {
			<span class="hljs-keyword">const</span> diags = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(collection.<span class="hljs-title function_">get</span>(uri) || []);
			diags.<span class="hljs-title function_">push</span>(diagnostic);
			collection.<span class="hljs-title function_">set</span>(uri, diags);
		}
	} <span class="hljs-keyword">else</span> {
		collection.<span class="hljs-title function_">clear</span>();
	}
}

<span class="hljs-comment">/**
 * Get from the token the code fragment, with a `#line linenmbr &quot;file&quot;\n` string
 * prepended.
 * <span class="hljs-doctag">@param</span> token Token with code
 * <span class="hljs-doctag">@param</span> env GrabbedState environment the token belongs to, for the filename
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">decorateCodeWithLine</span>(<span class="hljs-params">token: Token, _: GrabbedState</span>) : <span class="hljs-built_in">string</span> {
	<span class="hljs-comment">// line number we want is tag location plus one, since code starts on that</span>
	<span class="hljs-comment">// next line.</span>
	<span class="hljs-comment">/*
	let linenumber = locationOfFragment(token) + 1;
	let code = &#x27;&#x27;;
	if (linenumber&gt;=0) {
		code = `#line ${linenumber} &quot;${env.filename}&quot;`;
	}
	code = `${code}\n${token.content.trim()}`;
	*/</span>
	<span class="hljs-keyword">return</span> token.<span class="hljs-property">content</span>;
}

<span class="hljs-comment">/**
 * Create diagnostic for a given token with message.
 * <span class="hljs-doctag">@param</span> token Token that carries the faulty code fragment
 * <span class="hljs-doctag">@param</span> message Error message
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createErrorDiagnostic</span>(<span class="hljs-params">token: Token, message: <span class="hljs-built_in">string</span></span>) : vscode.<span class="hljs-property">Diagnostic</span> {
	<span class="hljs-keyword">let</span> range = <span class="hljs-title function_">fragmentRange</span>(token);
	<span class="hljs-keyword">let</span> <span class="hljs-attr">diagnostic</span>: vscode.<span class="hljs-property">Diagnostic</span> = {
		<span class="hljs-attr">severity</span>: vscode.<span class="hljs-property">DiagnosticSeverity</span>.<span class="hljs-property">Error</span>,
		<span class="hljs-attr">message</span>: message,
		<span class="hljs-attr">range</span>: range
	};

	<span class="hljs-keyword">return</span> diagnostic;
}

<span class="hljs-comment">/**
 * Give the location of the line in the Markup document that contains the
 * tag declaration.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragment</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
	<span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>]) : -<span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> linenumber;
}

<span class="hljs-comment">/**
 * Give the location of the last line in the Markup document that contains the
 * code fragment.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragmentEnd</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
	<span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>] ) : -<span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> linenumber;
}


<span class="hljs-comment">/**
 * Give range for the code fragment, including tag.
 * <span class="hljs-doctag">@param</span> token Token to create range for
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fragmentRange</span>(<span class="hljs-params">token: Token</span>): vscode.<span class="hljs-property">Range</span> {
	<span class="hljs-keyword">let</span> startTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>) + <span class="hljs-number">2</span>;
	<span class="hljs-keyword">let</span> endTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>) - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragment</span>(token), startTagName);
	<span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragmentEnd</span>(token), endTagName);
	<span class="hljs-keyword">let</span> <span class="hljs-attr">range</span>: vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(start, end);
	<span class="hljs-keyword">return</span> range;
}

<span class="hljs-comment">/*
let languageMapping = new Map&lt;string, string&gt;();
function setupLanguageMapping() {
	languageMapping.set(&quot;csharp&quot;, &quot;cs&quot;);
}

function extensionForLanguage(lang: string): string
{
	lang = lang.trim();
	if (lang.length &lt;= 2) {
		return lang;
	}

	if (languageMapping.has(lang)) {
		let extension = languageMapping.get(lang);
		if (extension) {
			return extension;
		}
	}

	return &#x27;xx&#x27;;
}

*/</span>

<span class="hljs-comment">// this method is called when your extension is deactivated</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deactivate</span>(<span class="hljs-params"></span>) {}

</code></pre>
</div></div>
	</body>
</html>
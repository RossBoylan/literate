<html>
    <head>
      <link rel="stylesheet" type="text/css" href="./style.css">
    </head>
    <body>
    <h1>Literate Programming</h1>
<p><strong>Literate programming</strong> is a programming paradigm introduced by Donald Knuth. A
program is written in a natural language with snippets of code interspersed.
From this text usable source code is generated, along with well formatted
human-readable document.</p>
<p>The most important influence for this <strong>literate programming</strong> extension is the
<a href="https://pbr-book.org">PBR Book</a>.</p>
<p>This extension provides a set of tools that help the programmer writing literate
programs. Through automation the process of writing literate programs should be
as painless as possible. The programming writes his literate programs using
Markdown. When a literate programmer needs a snippet they can add a code fence.
In this extension snippets are called code fragments.</p>
<p>The approach for this extension is based on Markdown documents, as noted
earlier. The Markdown specification is only slightly adapted to make supporting
<strong>literate programming</strong> easy. The code fragments are expressed in code fences
as per the Markdown specification, either with surrounding tripple backticks or
tripple tildes. Along with the programming language identifier the opening line
has been extended to contain the fragment name and type as essentially options
to the code fence. This opening line thus will look like
<code>py : &lt;&lt;fragment name&gt;&gt;</code> to create a new fragment, or like
<code>py : &lt;&lt;fragment name&gt;&gt;=+</code> to amend an existing fragment.</p>
<p>To create actual source files a fragment creation line needs to be used with a
slightly extended form of the creation tag mentioned above. The name has to be
postixed with the string <code>.*</code> betueen the chevrons. Furthermore a file
name needs to be specied after the equal sign. This is essentially a relative
path that is going to be appended each workspace folder as the root. A top level
fragment looks like <code>py : &lt;&lt;top-level fragment.*&gt;&gt; ./src/source.py</code>. The
name of this fragment is <code>top-level fragment</code>, and once it has been fully
extrapolated will be written to a file in the workspace folder under <code>src</code> as
the file <code>source.py</code>.</p>
<p>The <strong>Literate Programming</strong> extension allows the program author to write
multiple projects in the same Visual Studio Code workspace. Each workspace
folder is the root for its own literate project. Within each project there can
be one or more <strong>literate</strong> files. These files have the extension <code>.literate</code>.
One literate file can contain zero or more code fragments. A literate file can
also contain more than one top level fragment. In other words an author can
create multiple source files within just one <strong>literate</strong> document.</p>
<p>This text describes the <strong>Literate Programming</strong> extension as a <strong>literate</strong>
program.</p>
<h2>Iterating all literate files</h2>
<p>As mentioned in the introduction the main idea of the extension is to collect
all fragments that are created in all <code>.literate</code> files. Once all fragments have
been collected they are extrapolated until the top fragments are the full source
files. Fully extrapolated top fragments are written to the source files as
specicied for them.</p>
<p>The first step is to put each <code>.literate</code> file through the <em>MarkdownIt</em>
renderer. Each rendering will be given a special environment that will be used
to collect the state for the render. The state will contain the document
tokenized according the Markdown specification. The state <code>env</code> is of type
<code>GrabbedState</code>. Among the tokens will be the code fences that are code
fragments. For each <code>.literate</code> file the grabbed state <code>env</code> is saved in the
list of <code>GrabbedState</code>s <code>envList</code>.</p>
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">iterateLiterateFiles</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder,
                                    writeHtml : WriteRenderCallback
                                                | <span class="hljs-literal">undefined</span>
                                                | <span class="hljs-literal">null</span>,
                                    envList : <span class="hljs-built_in">Array</span>&lt;GrabbedState&gt;,
                                    md : MarkdownIt</span>)
{
  &lt;&lt;find all literate files <span class="hljs-keyword">in</span> workspace&gt;&gt;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fl <span class="hljs-keyword">of</span> foundLiterateFiles) {
      &lt;&lt;get text <span class="hljs-variable language_">document</span> content <span class="hljs-keyword">if</span> available&gt;&gt;
      &lt;&lt;get text <span class="hljs-keyword">from</span> literate <span class="hljs-variable language_">document</span>&gt;&gt;
      &lt;&lt;parse literate file&gt;&gt;
      &lt;&lt;write out rendered file <span class="hljs-keyword">if</span> requested&gt;&gt;
    }
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);
  }
}
</code></pre>
<p>We ensure that only <strong>literate</strong> files are going to be parsed for their program
fragments. We do that by using a <code>vscode.RelativePattern</code> using the workspace
folder passed into <code>iterateLiterateFiles</code>.</p>
<pre><code><span class="hljs-keyword">const</span> literateFilesInWorkspace : vscode.<span class="hljs-property">RelativePattern</span> =
          <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">RelativePattern</span>(workspaceFolder, <span class="hljs-string">&#x27;**/*.literate&#x27;</span>);
<span class="hljs-keyword">const</span> foundLiterateFiles = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>
          .<span class="hljs-title function_">findFiles</span>(literateFilesInWorkspace)
          .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file)));
</code></pre>
<p>For each <strong>literate</strong> file in the workspace we'll get eventually the text
content, but we do have to check if any of the files are opened in an editor.
Especially for on-the-fly updating of the tree view, but also for fragment name
completion and similar functionality we need to get the text from the
<code>TextDocument</code> instead of the file on disk. If there is a <code>TextDocument</code> that
corresponds to the <strong>literate</strong> file we are currently handling we read the text
into <code>currentContent</code>, otherwise we set it to an empty string.</p>
<pre><code><span class="hljs-keyword">const</span> currentContent = (<span class="hljs-function">() =&gt;</span>
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> textDocument <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">textDocuments</span>) {
      <span class="hljs-keyword">if</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">asRelativePath</span>(fl) === vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">asRelativePath</span>(textDocument.<span class="hljs-property">uri</span>)) {
        <span class="hljs-keyword">return</span> textDocument.<span class="hljs-title function_">getText</span>();
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
  }
)();
</code></pre>
<p>If <code>currentContent</code> is an empty string we read the content from the file on
disk, and decode it into <code>text</code>. If on the other hand we do have
<code>currentContent</code>, we use that for our <code>text</code> instead. The <code>currentContent</code>
wil be more up-to-date than what we have on disk.</p>
<pre><code><span class="hljs-keyword">const</span> content = currentContent ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">readFile</span>(fl);
<span class="hljs-keyword">const</span> text = currentContent ? currentContent : <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">decode</span>(content);
</code></pre>
<p>With the <code>text</code> for our <strong>literate</strong> document ready we harvest the relative file
path to our document from the workspace folder. <code>fname</code> is then set as the
<code>literateFileName</code> of our <code>GrabbedState</code> instance that we push into the
<code>envList</code> so that we can access it later. Now we finally get to pass the <code>text</code>
of our <strong>literate</strong> document to the <em>MarkdownIt</em> renderer. Once that is done we
have both an HTML representation of our document as well as the entire parser
state in <code>env</code>.</p>
<pre><code><span class="hljs-keyword">const</span> fname = path.<span class="hljs-title function_">relative</span>(workspaceFolder.<span class="hljs-property">uri</span>.<span class="hljs-property">path</span>, fl.<span class="hljs-property">path</span>);
<span class="hljs-keyword">const</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span> = { <span class="hljs-attr">literateFileName</span>: fname, <span class="hljs-attr">literateUri</span>: fl, <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, md, {}) };
envList.<span class="hljs-title function_">push</span>(env);
<span class="hljs-keyword">const</span> rendered = md.<span class="hljs-title function_">render</span>(text, env);
</code></pre>
<p>If a callback implementing <code>WriteRenderCallback</code> is passed to
<code>iterateLiterateFiles</code> we call that with the endered file content so that it can
be saved as an <code>HTML</code> file with the same name as the <code>.literate</code> file that was
being rendered, but with the extension replaced with <code>.html</code>. Conversely, if no
callback was passed in it is not called and rendered results are not saved to
disk.</p>
<pre><code><span class="hljs-keyword">if</span>(writeHtml)
{
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">writeHtml</span>(fname, workspaceFolder.<span class="hljs-property">uri</span>, rendered);
}
</code></pre>
<h3>GrabbedState interface</h3>
<p>The <code>GrabbedState</code> interface is used to create a type that helps us collecting
the tokens for each <code>.literate</code> file. Instances of objects with this interface
are passed to a <em>MarkdownIt</em> renderer. The renderer will have the
<code>GrabberPlugin</code> registered, which provides a rule that helps us collecting the
states of each rendered file. The grabbed state is collected in <code>gstate</code>, which
is an instance of the <code>StateCore</code>, provided by <em>MarkdownIt</em>.</p>
<pre><code><span class="hljs-comment">/**
 * Interface for environment to hold the Markdown file name and the StateCore
 * grabbed by the grabberPlugin.
 * The gstate we use to access all the tokens generated by the MarkdownIt parser.
 *
 * <span class="hljs-doctag">@see</span> <span class="hljs-variable">StateCore</span>
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">GrabbedState</span> {
  <span class="hljs-comment">/**
   * File name of the Markdown document to which the state belongs.
   */</span>
  <span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * Uri for the Markdown document.
   */</span>
  <span class="hljs-attr">literateUri</span>: vscode.<span class="hljs-property">Uri</span>;
  <span class="hljs-comment">/**
   * State grabbed from the MarkdownIt parser.
   */</span>
  <span class="hljs-attr">gstate</span>: <span class="hljs-title class_">StateCore</span>;
}
</code></pre>
<h2>Preparing MarkdownIt</h2>
<p>In the <code>iterateLiterateFiles</code> we start by setting up the <em>MarkdownIt</em> parser.</p>
<pre><code><span class="hljs-comment">/**
  * MarkdownIt instance with grabber_plugin in use.
  */</span>
<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
</code></pre>
<p>The function <code>createMarkdownItParserForLiterate</code> does this setup so that it is
easy to get a new parser to use for different purposes, like parsing documents
to get the code fragment names for code completion.</p>
<p>The highlight function we use to ensure our code fragments get syntax
highlighting. This simply relies on <em>highlight.js</em> to do the work.</p>
<p>We also tell <em>MarkdownIt</em> to use our <code>grabberPlugin</code>. This plug-in harvests the
internal states for each document into instances of <code>GrabbedState</code>. These states
we'll later use to get all the different code fragments and to weave them into
the code files they describe.</p>
<p>Finally we replace the default <code>fence</code> rule with our own <code>renderCodeFence</code> rule.
The intent of that rule will be explained in the section on <code>renderCodeFence</code>.</p>
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createMarkdownItParserForLiterate</span>(<span class="hljs-params"></span>) : <span class="hljs-title class_">MarkdownIt</span>
{
  <span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
          <span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, lang: <span class="hljs-built_in">string</span>, attrs: <span class="hljs-built_in">string</span></span>) {
            <span class="hljs-keyword">if</span>(lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&lt;code&gt;&#x27;</span> +
              hljs.<span class="hljs-title function_">highlight</span>(str, {language : lang}).<span class="hljs-property">value</span> +
              <span class="hljs-string">&#x27;&lt;/code&gt;&lt;/pre&gt;&#x27;</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre title=&quot;&#x27;</span> + attrs + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span> + md.<span class="hljs-property">utils</span>.escapeHtml(str) + <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>;
          }
      
        })
        .<span class="hljs-title function_">use</span>(grabberPlugin);
      
      oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
      md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
  <span class="hljs-keyword">return</span> md;
}
</code></pre>
<h2>Fragment structure and regular expressions</h2>
<p>Before we dive deeper into the processing of <code>.literate</code> documents it is
necessary to have a look at how fragments work.</p>
<p>Fragments in the <code>literate</code> extension have a specific format that requires a bit
of explaining.</p>
<p>There are four types of fragment tags, three of which either create or modify a
fragment, and one that expresses fragment usage.</p>
<p>For the detection of fragments a couple of regular expressions are used. These
are explained in more detail below.</p>
<h3>Fragment use in code</h3>
<p>Lets start by looking at the form for fragment tag use.</p>
<p>Fragments can be used in code blocks by using their tag double opening and
closing chevrons around the fragment name <code>&lt;&lt;fragment name&gt;&gt;</code>. To detect usage
of fragments in code we use <code>FRAGMENT_USE_IN_CODE_RE</code>.</p>
<pre><code><span class="hljs-comment">//let HTML_ENCODED_FRAGMENT_TAG_RE = /(&amp;lt;&amp;lt.*?&amp;gt;&amp;gt;)/g;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span> =
  <span class="hljs-regexp">/(?&lt;indent&gt;[ \t]*)&lt;&lt;(?&lt;tagName&gt;.*)&gt;&gt;(?&lt;root&gt;=)?(?&lt;add&gt;\+)?/g</span>;
</code></pre>
<p>The regular expression captures four groups. A match will give us 5 or more
results, the whole string matched and the captured groups. There may be some
additional parts after that, but those we will discard. The whole string matched
is called the <code>tag</code>. The first group is called <code>indent</code>, which will be used to
indent the whole fragment code when it gets extrapolated into the final code.
The second group is called <code>tagName</code>, which is the fragment name. The third
group is called <code>root</code> and the final group is called <code>add</code>. For fragment use we
essentially need only the second group <code>tagName</code>, with the <code>indent</code> still
serving a function. The other groups are in the regular expression so we can
identify incorrect use of fragments in code: creating or adding to fragments
inside code blocks is not valid.</p>
<p>The application of <code>FRAGMENT_USE_IN_CODE_RE</code> is explained in more detail in the
section on code realization.</p>
<h3>Creating and modifying fragments</h3>
<p>There is the tag used to create a new fragment, which is always in conjunction
with the opening code fence tag. This means either a triple backtick or triple
tilde followed by the programming language identifier for the following code
block. The actual fragment tag is placed as first option right after the colon
following the language specifier.</p>
<pre><code><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_RE</span> =
  <span class="hljs-regexp">/(?&lt;lang&gt;.*):.*&lt;&lt;(?&lt;tagName&gt;.*)&gt;&gt;(?&lt;root&gt;=)?(?&lt;add&gt;\+)?\s*(?&lt;fileName&gt;.*)/</span>;
</code></pre>
<p>Most of the groups correspond to the ones defined by <code>FRAGMENT_USE_IN_CODE_RE</code>
with a few additions. Most notably there is the group catching the language
specifier, and the group to catch the filename, called <code>lang</code> and <code>fileName</code>
respectively.</p>
<p>So to create a new tag the info line for the code fence could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=</code>.</p>
<p>To add to a fragment a <code>+</code> is added, so it could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=+</code>. Having a fragment without <code>=</code> or <code>=+</code> on the code
fence info line is an error.</p>
<h2>Gathering all fragments</h2>
<p>All code fragments are fetched from each environment state. This is done through
looking for all <code>fence</code> tokens. If the <code>token.info</code> for a <code>fence</code> matches the
<code>FRAGMENT_RE</code> we can check to see whether the fragment we have currently in our
hands is a new fragment (<code>root &amp;&amp; !add</code>) or whether this one expands an existing
one (<code>root &amp;&amp; add</code>), as will be explained in more detail further down.</p>
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFragments</span>(<span class="hljs-params">
  workspaceFolder : vscode.WorkspaceFolder,
  envList : <span class="hljs-built_in">Array</span>&lt;GrabbedState&gt;,
  diagnostics : vscode.DiagnosticCollection,
  extrapolateFragments : <span class="hljs-built_in">boolean</span>,
  writeSource : WriteSourceCallback | <span class="hljs-literal">undefined</span></span>) : <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;&gt;
{
  <span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
  &lt;&lt;build fragment map&gt;&gt;

  <span class="hljs-keyword">if</span>(extrapolateFragments)
  {
    &lt;&lt;extrapolate fragments&gt;&gt;
  }

  <span class="hljs-keyword">if</span>(writeSource) {
    <span class="hljs-title function_">writeSource</span>(workspaceFolder, fragments);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(fragments);
}
</code></pre>
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">writeSourceFiles</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder,
                fragments : <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, FragmentInformation&gt;</span>)
{
  <span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
  <span class="hljs-comment">/* now write out the source files. */</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
    <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">if</span> (fragmentInfo) {
        <span class="hljs-keyword">let</span> fileName = fragmentInfo.<span class="hljs-property">sourceFileName</span>.<span class="hljs-title function_">trim</span>();
        <span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(fragmentInfo.<span class="hljs-property">code</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
        <span class="hljs-keyword">const</span> fileUri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">joinPath</span>(folderUri, fileName);
        <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
      }
    }
  }
}
</code></pre>
<h3>Populating the fragment map</h3>
<p>First we build a map of all available fragments. These will go into <code>fragments</code>,
which is of type <code>Map&lt;string, FragmentInformation&gt;</code>. The name of a fragment will
function as the key, and an instance of <code>FragmentInformation</code> will be the value.</p>
<pre><code><span class="hljs-comment">/**
 * Map of fragment names and tuples of code fragments for these. The
 * tuples contain code language identifier followed by the filename and
 * lastly followed by the actual code fragment.
 */</span>
<span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;();
<span class="hljs-comment">// Now we have the state, we have access to the tokens</span>
<span class="hljs-comment">// over which we can iterate to extract all the code</span>
<span class="hljs-comment">// fragments and build up the map with the fragments concatenated</span>
<span class="hljs-comment">// where necessary. We&#x27;ll extrapolate all fragments in the second</span>
<span class="hljs-comment">// pass.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> env <span class="hljs-keyword">of</span> envList) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> token <span class="hljs-keyword">of</span> env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>) {
    &lt;&lt;handle fence tokens&gt;&gt;
  }
}
</code></pre>
<p>Each <code>fence</code> token we find we need to check. There may be of course code fences
in the document that do not create or modify a fragment. These we need to skip.</p>
<p>Since we are handling code fences we use <code>FRAGMENT_RE</code> to match <code>token.info</code>.</p>
<pre><code><span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span>) {
  <span class="hljs-keyword">const</span> linenumber = <span class="hljs-title function_">locationOfFragment</span>(token);
  <span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
  <span class="hljs-keyword">if</span> (match &amp;&amp; match.<span class="hljs-property">groups</span>) {
    <span class="hljs-keyword">let</span> lang = match.<span class="hljs-property">groups</span>.<span class="hljs-property">lang</span>.<span class="hljs-title function_">trim</span>();
    <span class="hljs-keyword">let</span> name = match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>;
    <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
    <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
    <span class="hljs-keyword">let</span> fileName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">fileName</span>;
    &lt;&lt;add to existing fragment&gt;&gt;
    &lt;&lt;create a <span class="hljs-keyword">new</span> fragment&gt;&gt;
  }
}
</code></pre>
<h3>Creating a new fragment</h3>
<p>If the <code>root</code> group has captured a result, but the <code>add</code> group not we know we
have a new fragment on our hand.</p>
<p>If we already have in our <code>fragments</code> map a key with the same <code>name</code> as the
fragment we are currently handling we add an error diagnostic message. We don't
stop handling fences, or the entire <code>literate.process</code> command for that matter.
We keep on going, but leave it up to the programmer to see and handle the error
messages.</p>
<p>If a fragment name with <code>.*</code> is found we need to ensure there is a result in the
<code>fileName</code> capture group. That is going to be needed to write out the source
code file eventually. A file defining fragment without a file name is an error.</p>
<p>When everything appears to be in order a new <code>FragmentInformation</code> instance is
created with the information found. The code for this fragment is the token
content in <code>token.content</code>. Finally the new <code>FragmentInformation</code> instance is
added to the <code>fragments</code> map.</p>
<pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; !add) {
  <span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
    <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to overwrite existing fragment fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span><span class="hljs-subst">${linenumber}</span>`</span>;
    <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
    <span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (!fileName &amp;&amp; name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt; -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Expected filename for star fragment <span class="hljs-subst">${name}</span>`</span>;
      <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
      <span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> code = token.<span class="hljs-property">content</span>;
      <span class="hljs-keyword">let</span> <span class="hljs-attr">fragmentInfo</span>: <span class="hljs-title class_">FragmentInformation</span> = {
        <span class="hljs-attr">lang</span>: lang,
        <span class="hljs-attr">literateFileName</span>: env.<span class="hljs-property">literateFileName</span>,
        <span class="hljs-attr">sourceFileName</span>: fileName,
        <span class="hljs-attr">code</span>: code,
        <span class="hljs-attr">tokens</span>: [token],
        <span class="hljs-attr">env</span>: env,
      };
      fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
    }
  }
}
</code></pre>
<h3>Modifying an exiting fragment</h3>
<p>If both the <code>root</code> and <code>add</code> groups have capture their results, an <code>=</code> and an
<code>+</code> respectively we need to add code to an existing fragment.</p>
<p>For this to work a new fragment needs to be always present before the modifying
fragment. It is an error to try to modify a fragment that hasn't been seen yet.</p>
<p>The fragment with specified <code>name</code> is fetched, and when it is not <code>undefined</code>
the <code>token.content</code> is appended to the <code>code</code> of the <code>FragmentInformation</code>
instance we got from the map. The current token is also appended to the <code>tokens</code>
list.</p>
<p>The fragments map is updated with the modified  <code>FragmentInformation</code> instance.</p>
<pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; add) {
  <span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
    <span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">if</span>(fragmentInfo &amp;&amp; fragmentInfo.<span class="hljs-property">code</span>) {
      <span class="hljs-keyword">let</span> additionalCode = token.<span class="hljs-property">content</span>;
      fragmentInfo.<span class="hljs-property">code</span> = <span class="hljs-string">`<span class="hljs-subst">${fragmentInfo.code}</span><span class="hljs-subst">${additionalCode}</span>`</span>;
      fragmentInfo.<span class="hljs-property">tokens</span>.<span class="hljs-title function_">push</span>(token);
      fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to add to non-existant fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span>:<span class="hljs-subst">${linenumber}</span>`</span>;
    <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
    <span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
  }
}
</code></pre>
<h3>The FragmentInformation type</h3>
<p>We have now seen the <code>FragmentInformation</code> type being used several times, so it
is important to take a moment to clarify it in more detail.</p>
<p>The interface allows us to gather information for each found code fragment. It
allows us to store the programming language identifier, name of the <code>.literate</code>
file and name of the targeted source file, if the code fragment happens to be a
top fragment.</p>
<p>The actual code for the fragment is stored in <code>code</code>. Furthermore the tokens for
the complete fragment are stored in the <code>tokens</code> list. This list is of objects
that fullfill the <code>Token</code> interface, which is provided by the <em>MarkdownIt</em>
module.</p>
<pre><code><span class="hljs-comment">/**
 * Interface denoting a fragment and related information
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FragmentInformation</span> {
  <span class="hljs-comment">/**
   * Programming language identifier for fragment.
   */</span>
  <span class="hljs-attr">lang</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * Filename of literate file.
   */</span>
  <span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * Filename of target source file. This is set when the fragment
   * is a top fragment.
   */</span>
  <span class="hljs-attr">sourceFileName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * The code fragment.
   */</span>
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/**
   * List of tokens that make up the entire code fragment.
   */</span>
  <span class="hljs-attr">tokens</span>: <span class="hljs-title class_">Token</span>[];
  <span class="hljs-comment">/**
   * The GrabbedState related to this fragment.
   */</span>
  <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span>;
}
</code></pre>
<h2>Extrapolating fragments</h2>
<p>Once all fragments have been collected from the <code>.literate</code> files of the project
fragments can be combined into source code.</p>
<pre><code><span class="hljs-comment">// for now do several passes</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pass</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">do</span> {
  pass++;
  <span class="hljs-keyword">let</span> fragmentReplaced = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
    <span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">if</span> (!fragmentInfo) {
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
      <span class="hljs-keyword">if</span>(!match || !match.<span class="hljs-property">groups</span>) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">let</span> tag = match[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">let</span> indent = match.<span class="hljs-property">groups</span>.<span class="hljs-property">indent</span>;
      <span class="hljs-keyword">let</span> tagName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>;
      <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
      <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
      <span class="hljs-keyword">if</span> (root) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;=&#x27;: incorrect fragment tag in fragment, <span class="hljs-subst">${tag}</span>`</span>;
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
        <span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
      }
      <span class="hljs-keyword">if</span> (add) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;+&#x27;: incorrect fragment tag in fragment: <span class="hljs-subst">${tag}</span>`</span>;
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
        <span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
      }
      <span class="hljs-keyword">if</span> (!fragments.<span class="hljs-title function_">has</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>) &amp;&amp; tagName !== <span class="hljs-string">&quot;(?&lt;tagName&gt;.*)&quot;</span>) {
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Could not find fragment <span class="hljs-subst">${tag}</span> (<span class="hljs-subst">${tagName}</span>)`</span>;
        <span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
        <span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
      }
      <span class="hljs-keyword">let</span> fragmentToReplaceWith = fragments.<span class="hljs-title function_">get</span>(tagName) || <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">if</span> (fragmentToReplaceWith) {
        <span class="hljs-keyword">let</span> code = fragmentToReplaceWith.<span class="hljs-property">code</span>;
        <span class="hljs-keyword">let</span> lines = code.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">let</span> indentedLines = lines.<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e, _</span>) {
          <span class="hljs-keyword">return</span> indent + e;

        });
        <span class="hljs-keyword">let</span> newcode = indentedLines.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
        fragmentReplaced = <span class="hljs-literal">true</span>;
        fragmentInfo.<span class="hljs-property">code</span> = fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">replace</span>(tag, newcode);
        fragments.<span class="hljs-title function_">set</span>(fragmentName, fragmentInfo);
      }
    }
  }
  <span class="hljs-keyword">if</span>(!fragmentReplaced) {
    <span class="hljs-keyword">break</span>;
  }
}
<span class="hljs-keyword">while</span> (pass &lt; <span class="hljs-number">25</span>);
</code></pre>
<h2>custom code fence rendering</h2>
<p>Our extension uses a custom code fence rendering rule to ensure the code
fragment name is also rendered as part of the fence.</p>
<p>Essentially the old, default rendering rule for fences is first used to create
the original fence.</p>
<p>Then the <code>token.info</code> is matched against the <code>FRAGMENT_RE</code> regular expression.
If we have a match we prepare the <code>HTML</code> code to essentially wrap around the
<code>HTML</code> as generated by the default rule.</p>
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderCodeFence</span>(<span class="hljs-params">tokens : Token[],
             idx : <span class="hljs-built_in">number</span>,
             options : MarkdownIt.Options,
             env : <span class="hljs-built_in">any</span>,
             slf : Renderer</span>) {
  <span class="hljs-keyword">let</span> rendered = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">if</span> (oldFence) {
    rendered = <span class="hljs-title function_">oldFence</span>(tokens, idx, options, env, slf);

    <span class="hljs-keyword">let</span> token = tokens[idx];
    <span class="hljs-keyword">if</span> (token.<span class="hljs-property">info</span>) {
      <span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
      <span class="hljs-keyword">if</span> (match &amp;&amp; match.<span class="hljs-property">groups</span>) {
        <span class="hljs-keyword">let</span> lang = match.<span class="hljs-property">groups</span>.<span class="hljs-property">lang</span>.<span class="hljs-title function_">trim</span>();
        <span class="hljs-keyword">let</span> name = match.<span class="hljs-property">groups</span>.<span class="hljs-property">name</span>;
        <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
        <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
        <span class="hljs-keyword">let</span> fileName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">fileName</span>;
        <span class="hljs-keyword">if</span> (name) {
          root = root || <span class="hljs-string">&#x27;&#x27;</span>;
          add = add || <span class="hljs-string">&#x27;&#x27;</span>;
          rendered =
<span class="hljs-string">`&lt;div class=&quot;codefragment&quot;&gt;
&lt;div class=&quot;fragmentname&quot;&gt;&amp;lt;&amp;lt;<span class="hljs-subst">${name}</span>&amp;gt;&amp;gt;<span class="hljs-subst">${root}</span><span class="hljs-subst">${add}</span>&lt;/div&gt;
&lt;div class=&quot;code&quot;&gt;
<span class="hljs-subst">${rendered}</span>
&lt;/div&gt;
&lt;/div&gt;`</span>;
        }
      }
    }
  }

  <span class="hljs-keyword">return</span> rendered;
};
</code></pre>
<h2>Register the literate.process command</h2>
<p>The command <code>literate.process</code> is registered with Visual Studio Code. The
disposable that gets returned by <code>registerCommand</code> is held in
<code>literateProcessDisposable</code> so that it can be used later on, for instance for
diagnostics management.</p>
<p>Here we find the main program of our <code>literate.process</code> command. Our
<em>MarkdownIt</em> is set up, <code>.literate</code> files are searched and iterated. Each
<code>.literate</code> file is rendered, and code fragments are harvested. Finally code
fragments are extrapolated and saved to their respective source code files. The
<code>HTML</code> files are also saved to files.</p>
<p>Diagnostic messages are also handled here. Errors and warnings are shown where
necessary. On successfull completion a simple status bar message will be used.
An information diagnostic message is not good here, because that will prevent
the usage of <code>literate.process</code> in for instance <code>tasks.json</code>, since the
diagnostic message will block execution of a task if it were used as prelaunch
task. That is obviously not good for the workflow.</p>
<pre><code><span class="hljs-keyword">let</span> literateProcessDisposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(
  <span class="hljs-string">&#x27;literate.process&#x27;</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {

  &lt;&lt;set up <span class="hljs-title class_">MarkdownIt</span>&gt;&gt;

  diagnostics.<span class="hljs-title function_">clear</span>();

  <span class="hljs-keyword">if</span> (!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>) {
    <span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&quot;No workspace or folder opened&quot;</span>);
  }


  <span class="hljs-keyword">const</span> writeOutHtml : <span class="hljs-title class_">WriteRenderCallback</span> =
      (fname : <span class="hljs-built_in">string</span>,
       folderUri : vscode.<span class="hljs-property">Uri</span>,
       rendered : <span class="hljs-built_in">string</span>) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
    <span class="hljs-keyword">const</span> html =
<span class="hljs-string">`&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
  <span class="hljs-subst">${rendered}</span>
  &lt;/body&gt;
&lt;/html&gt;`</span>;
    <span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(html, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
    fname = fname.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.literate&quot;</span>, <span class="hljs-string">&quot;.html&quot;</span>);
    <span class="hljs-keyword">const</span> fileUri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">joinPath</span>(folderUri, fname);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded));
  };

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> workspaceFolder <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">envList</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(workspaceFolder, writeOutHtml, envList, md);
        <span class="hljs-keyword">let</span> _ = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(workspaceFolder, envList, diagnostics, <span class="hljs-literal">true</span>, writeSourceFiles);
  }

  <span class="hljs-keyword">let</span> hasAnyDiagnostics = <span class="hljs-literal">false</span>;
  diagnostics.<span class="hljs-title function_">forEach</span>(
    <span class="hljs-keyword">function</span>(<span class="hljs-params">
      _: vscode.Uri,
      diags: <span class="hljs-keyword">readonly</span> vscode.Diagnostic[],
      __: vscode.DiagnosticCollection
    </span>) : <span class="hljs-built_in">any</span> {
      hasAnyDiagnostics ||= (diags.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>);
    }
  );

  <span class="hljs-keyword">if</span> (hasAnyDiagnostics) {
        <span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">setStatusBarMessage</span>(
            (<span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(
        <span class="hljs-string">&quot;$(error) Error encountered during process&quot;</span>
      )).<span class="hljs-property">value</span>, <span class="hljs-number">2000</span>);
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">setStatusBarMessage</span>(<span class="hljs-string">&quot;Literate Process completed&quot;</span>, <span class="hljs-number">5000</span>);
  }
});
</code></pre>
<h2>Fragment explorer</h2>
<p>The Literate Fragment Explorer is a <code>TreeView</code> that uses <code>FragmentNodeProvider</code>
to show fragments available in a workspace. The tree view has <code>FragmentNode</code> as
its type parameter.</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentExplorer</span> {
  <span class="hljs-keyword">private</span> fragmentView : vscode.<span class="hljs-property">TreeView</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">context : vscode.ExtensionContext</span>) {
    <span class="hljs-keyword">const</span> fragmentNodeProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNodeProvider</span>();
    context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
      vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">registerTreeDataProvider</span>(
        <span class="hljs-string">&#x27;fragmentExplorer&#x27;</span>,
        fragmentNodeProvider
      )
    );
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentView</span> = vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">createTreeView</span>(
                  <span class="hljs-string">&#x27;fragmentExplorer&#x27;</span>,
                  {
                    treeDataProvider : fragmentNodeProvider
                  });

    context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
      vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(
                <span class="hljs-string">&#x27;fragmentExplorer.refreshEntry&#x27;</span>,
                <span class="hljs-function">() =&gt;</span> fragmentNodeProvider.<span class="hljs-title function_">refresh</span>())
              );
    context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">onDidChangeTextDocument</span>(
      <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
        fragmentNodeProvider.<span class="hljs-title function_">refresh</span>();
      }
    ));
    context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragmentView</span>);
  }
}
</code></pre>
<h3>Fragment tree provider</h3>
<p>The Literate Fragment Explorer needs a
<a href="https://code.visualstudio.com/api/extension-guides/tree-view"><code>TreeDataProvider</code></a>
implementation to present the fragment structure to Visual Studio Code so that
the data can be visualized in the <code>fragmentExplorer</code> custom view.</p>
<p>The class <code>FragmentNodeProvider</code> implements a <code>TreeDataProvider</code> with
<code>FragmentNode</code> as the tree item.</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentNodeProvider</span> <span class="hljs-keyword">implements</span> vscode.<span class="hljs-property">TreeDataProvider</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;
{
  &lt;&lt;fragment node provider members&gt;&gt;
  &lt;&lt;fragment node provider <span class="hljs-variable constant_">API</span>&gt;&gt;
}
</code></pre>
<p>The constructor takes care of all necessary initialization.</p>
<pre><code><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
{
  &lt;&lt;initialize fragment node provider&gt;&gt;
}
</code></pre>
<p>The constructor for the <code>FragmentNodeProvider</code> creates an instance of the
<code>MarkdownIt</code> module, fully configured for our <strong>literate programming</strong> needs.
Additionally a <code>DiagnosticCollection</code> is created so that it can be passed on to
the <code>handleFragments</code> function that is utilized in the <code>FragmentNodeProvider</code>.</p>
<pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">md</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span> = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate-treeview&#x27;</span>);
</code></pre>
<p>This means we need two members to hold these instances.</p>
<pre><code><span class="hljs-keyword">private</span> md : <span class="hljs-title class_">MarkdownIt</span>;
<span class="hljs-keyword">private</span> diagnostics : vscode.<span class="hljs-property">DiagnosticCollection</span>;
</code></pre>
<p>The API for <code>FragmentNodeProvider</code> gives as method to update the tree view</p>
<pre><code><span class="hljs-title function_">refresh</span>(): <span class="hljs-built_in">void</span> {
  &lt;&lt;refresh fragment node provider&gt;&gt;
}
</code></pre>
<p>The current implementation simply fires the <code>onDidChangeTreeData</code> event but
could do more work if needed. To that end there is a private member for emitting
the event, and the actual event to which the event emitter is published.</p>
<pre><code><span class="hljs-keyword">private</span> <span class="hljs-attr">_onDidChangeTreeData</span>:
  vscode.<span class="hljs-property">EventEmitter</span>&lt;
    <span class="hljs-title class_">FragmentNode</span> |
    <span class="hljs-literal">undefined</span> |
    <span class="hljs-built_in">void</span>
  &gt; = <span class="hljs-keyword">new</span> vscode.<span class="hljs-property">EventEmitter</span>&lt;<span class="hljs-title class_">FragmentNode</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">void</span>&gt;();
<span class="hljs-keyword">readonly</span> onDidChangeTreeData :
  vscode.<span class="hljs-property">Event</span>&lt;
    <span class="hljs-title class_">FragmentNode</span> |
    <span class="hljs-literal">undefined</span> |
    <span class="hljs-built_in">void</span>
  &gt; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onDidChangeTreeData</span>.<span class="hljs-property">event</span>;
</code></pre>
<p>With those two in place the <code>refresh</code> function can fire the event whenever
called.</p>
<pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">_onDidChangeTreeData</span>.<span class="hljs-title function_">fire</span>();
</code></pre>
<p>The <code>TreeDataProvider</code> implementation provided by <code>FragmentNodeProvider</code> is
completed by <code>getTreeItem</code> and <code>getChildren</code>. The first one is simple, it just
returns the element that is passed to it, as there is no need to find out more
information about this. Instead, elements have been already created by the
<code>getChildren</code> function, where all <code>FragmentNode</code> instances are created with all
the data necessary.</p>
<pre><code><span class="hljs-title function_">getTreeItem</span>(element : <span class="hljs-title class_">FragmentNode</span>): vscode.<span class="hljs-property">TreeItem</span> {
  &lt;&lt;get fragment tree item&gt;&gt;
}
</code></pre>
<p>As said, the <code>getTreeItem</code> implementation remains simple</p>
<pre><code><span class="hljs-keyword">return</span> element;
</code></pre>
<p>On the other hand the <code>getChildren</code> function is more involved. Yet its job is
simple: get all <code>FragmentNode</code>s that represent the direct children of the
element given.</p>
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-title function_">getChildren</span>(element? : <span class="hljs-title class_">FragmentNode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">FragmentNode</span>[]&gt;
{
  &lt;&lt;get direct children&gt;&gt;
}
</code></pre>
<p>When the workspace has no workspace folders at all there will be no children to
return, as there are no <strong>literate</strong> documents to begin with.</p>
<pre><code><span class="hljs-keyword">if</span>(!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> ||
  (
    vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> &amp;&amp;
    vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-number">1</span>
  )) {
  vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&#x27;No fragments in empty workspace&#x27;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>([]);
}
</code></pre>
<p>If we do have workspace folders, but no element is given to look for children we
need to look at the all the fragments available in all documents across all
workspace folders. If on the other hand an element is given then its children
are retrieved.</p>
<pre><code><span class="hljs-keyword">if</span>(!element)
{
  &lt;&lt;get children <span class="hljs-keyword">for</span> workspace folders&gt;&gt;
}
<span class="hljs-keyword">else</span>
{
  &lt;&lt;get children <span class="hljs-keyword">for</span> element&gt;&gt;
}
</code></pre>
<p>When no element is passed we want the root of all the branches, where each
workspace folder is the root of its own branch.</p>
<p>To this end the children are all essentially the workspace folder names. Since
these are the work folders the fragments representing them have no <code>parentName</code>
specified. As <code>folderName</code> we pass on the workspace folder name. This is a
property all its children and the rest of its offspring inherit. The
<code>folderName</code> is used to find the correct workspace folder to search for the
given element and its offspring.</p>
<pre><code><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> wsFolder <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>)
{
    arr.<span class="hljs-title function_">push</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNode</span>(
      wsFolder.<span class="hljs-property">name</span>,
      <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">&#x27;$(book) (workspace folder)&#x27;</span>, <span class="hljs-literal">true</span>),
      <span class="hljs-string">&#x27;Workspace folder containing a literate project&#x27;</span>,
      vscode.<span class="hljs-property">TreeItemCollapsibleState</span>.<span class="hljs-property">Collapsed</span>,
      wsFolder.<span class="hljs-property">name</span>,
      <span class="hljs-literal">undefined</span>,
      wsFolder,
      <span class="hljs-literal">undefined</span>));
}
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(arr);
</code></pre>
<p>Getting the children for a given element is a bit more involved. First we set
up a constant <code>folderName</code> for ease of access. Then we also creat an array of
<code>FragmentNode</code>s.</p>
<pre><code><span class="hljs-keyword">const</span> folderName : <span class="hljs-built_in">string</span> = element.<span class="hljs-property">folderName</span>;
<span class="hljs-keyword">const</span> fldr : vscode.<span class="hljs-property">WorkspaceFolder</span> = element.<span class="hljs-property">workspaceFolder</span>;
<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;();
</code></pre>
<p>From the element we already learned the workspace folder for its project, so we
can use that directly to parse the <strong>literate</strong> content. With the <code>fragments</code>
map of the workspace folder in hand we can iterate over the keys in the
<code>fragments</code> map.</p>
<p>There are essentially two cases we need to check for. If the given element has
no <code>parentName</code> set we know it is a fragment in the document level, so a
fragment that was created. In contrast for a fragment there are child fragments,
meaning that in the fragment code block other fragments were used. These are
presented in the tree view as children to that fragment.</p>
<pre><code>&lt;&lt;get fragment family <span class="hljs-keyword">for</span> offspring search&gt;&gt;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>() )
{
  <span class="hljs-keyword">if</span>(!element.<span class="hljs-property">parentName</span>) {
    &lt;&lt;create fragment node <span class="hljs-keyword">for</span> <span class="hljs-variable language_">document</span> level&gt;&gt;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fragmentName === element.<span class="hljs-property">label</span>) {
    &lt;&lt;create fragment node <span class="hljs-keyword">for</span> fragment parent&gt;&gt;
  }
}

<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(arr);
</code></pre>
<h3>Getting all fragments</h3>
<p>To find the fragment information to build <code>FragmentNode</code>s from iterate over the
<strong>literate</strong> files in the workspace folder that we determined we need to search.
Then build the fragment map based on the tokens generated by the iteration pass.
As a reminder the fragments map has the fragment name as key and the
corresponding <code>FragmentInformation</code> as the value to that key.</p>
<pre><code><span class="hljs-keyword">let</span> <span class="hljs-attr">envList</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
<span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(fldr, <span class="hljs-literal">undefined</span>, envList, <span class="hljs-variable language_">this</span>.<span class="hljs-property">md</span>);
<span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(fldr, envList, <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>);
</code></pre>
<h3>TODO: build proper fragment hierarchy from fragments map</h3>
<p>Still to do. Right now essentially the map structure is shown, but that isn't
very useful. What we really need is a hierarchical form with each fragment under
its parent fragment so that the structure of the literate program can be seen.</p>
<p>Another improvement we could make is to show Markdown outline of chapters, with
fragment occurance under that shown.</p>
<h3>Fragment used in other fragment</h3>
<p>When we have found the fragment the passed in element represents we can find the
child fragment names, that is the fragment names used in this fragment. All
matches against <code>FRAGMENT_USE_IN_CODE_RE</code> are found and for each case a
corresponding <code>FragmentNode</code> is created to function as a child to our parent
element.</p>
<pre><code><span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">if</span> (fragmentInfo) {
  <span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
    <span class="hljs-keyword">if</span>(!match || !match.<span class="hljs-property">groups</span>)
    {
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">let</span> tag = match[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> ident = match.<span class="hljs-property">groups</span>.<span class="hljs-property">ident</span>;
    <span class="hljs-keyword">let</span> tagName = match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>;
    <span class="hljs-keyword">let</span> root = match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>;
    <span class="hljs-keyword">let</span> add = match.<span class="hljs-property">groups</span>.<span class="hljs-property">add</span>;
    arr.<span class="hljs-title function_">push</span>(
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNode</span>(
        tagName,
                <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">`$(symbol-file) <span class="hljs-subst">${fragmentInfo.literateFileName}</span>`</span>, <span class="hljs-literal">true</span>),
        fragmentName,
        vscode.<span class="hljs-property">TreeItemCollapsibleState</span>.<span class="hljs-property">Collapsed</span>,
        folderName,
        element.<span class="hljs-property">label</span>,
        element.<span class="hljs-property">workspaceFolder</span>,
        <span class="hljs-literal">undefined</span>
      )
    );
  }
}
</code></pre>
<h3>Fragment on document level</h3>
<p>When the workspace folder is given as the element, or rather the <code>parentName</code>
of the given element is undefined, we have a fragment on document level. There
are two types of fragments we want to discern beetween: top level fragments, or
fragments that also tell us what file to create, and other fragments. A
<strong>literate</strong> document can contain multiple top level fragments. But each top
level fragment will generate only one source code file.</p>
<pre><code><span class="hljs-keyword">let</span> fragmentType : vscode.<span class="hljs-property">MarkdownString</span>;
<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">if</span> (fragmentInfo) {
  <span class="hljs-keyword">if</span>(fragmentName.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>)
  {
    fragmentType = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(
              <span class="hljs-string">`$(globe): <span class="hljs-subst">${fragmentInfo.literateFileName}</span>`</span>,
              <span class="hljs-literal">true</span>);
  }
  <span class="hljs-keyword">else</span>
  {
    fragmentType = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(
              <span class="hljs-string">`$(code): <span class="hljs-subst">${fragmentInfo.literateFileName}</span>`</span>,
              <span class="hljs-literal">true</span>);
  }
    arr.<span class="hljs-title function_">push</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNode</span>(
      fragmentName,
      fragmentType,
      fragmentInfo.<span class="hljs-property">literateFileName</span>,
      vscode.<span class="hljs-property">TreeItemCollapsibleState</span>.<span class="hljs-property">Collapsed</span>,
      folderName,
      element.<span class="hljs-property">label</span>,
      element.<span class="hljs-property">workspaceFolder</span>,
      <span class="hljs-literal">undefined</span>));
}
</code></pre>
<h3>Fragment node for tree view</h3>
<p>A fragment node represents a <strong>literate</strong> project fragment in a Visual Studio
Code tree view. The class <code>FragmentNode</code> extends the <code>vscode.TreeItem</code>. Apart
from just showing basic information like the fragment name and the file it is
defined in we use <code>FragmentNode</code> also to keep track of the workspace folder it
is hosted in as well as the text document if there is one. Text documents are
documents the workspace currently has opened. We need to take these into
account so that we can directly use these as part of the <strong>literate</strong> document
parsing.</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">vscode.TreeItem</span>
{
  <span class="hljs-title function_">constructor</span> (
    &lt;&lt;fragment node <span class="hljs-keyword">readonly</span> members&gt;&gt;
  )
  {
    &lt;&lt;fragment node initialization&gt;&gt;
  }
}
</code></pre>
<p>For the visualization part we need a <code>label</code>, a <code>tooltip</code>, a <code>description</code> and a
<code>collapsibleState</code>. These are the only pieces of information needed that show up
in the tree view.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> label : <span class="hljs-built_in">string</span>,
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> tooltip : vscode.<span class="hljs-property">MarkdownString</span>,
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> description : <span class="hljs-built_in">string</span>,
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> collapsibleState : vscode.<span class="hljs-property">TreeItemCollapsibleState</span>,
</code></pre>
<p>We further encode some more information in <code>FragmentNode</code> so that subsequent
parsing can be done much more efficiently.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">folderName</span>: <span class="hljs-built_in">string</span>,
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> parentName : <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>,
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>,
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> textDocument : vscode.<span class="hljs-property">TextDocument</span> | <span class="hljs-literal">undefined</span>
</code></pre>
<p>Each node in the tree view represents a fragment. When the tree item is used to
denote a workspace folder the theme icon for <code>'book'</code> is used. Actual fragments
get the theme icon for <code>'code'</code>.</p>
<pre><code><span class="hljs-variable language_">super</span>(label, collapsibleState);
<span class="hljs-variable language_">this</span>.<span class="hljs-property">tooltip</span> = tooltip;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> = description;
<span class="hljs-variable language_">this</span>.<span class="hljs-property">iconPath</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentName</span> ?
          <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">ThemeIcon</span>(<span class="hljs-string">&#x27;code&#x27;</span>)
          : <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">ThemeIcon</span>(<span class="hljs-string">&#x27;book&#x27;</span>);
<span class="hljs-variable language_">this</span>.<span class="hljs-property">contextValue</span> = <span class="hljs-string">&#x27;literate_fragment&#x27;</span>;
</code></pre>
<h3>registering FragmentNodeProvider</h3>
<p>The <code>FragmentNodeProvide</code> needs to be registered with Visual Studio Code so it
can work when literate files are found in a work space.</p>
<pre><code><span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentExplorer</span>(context);
</code></pre>
<h2>Code completion</h2>
<p>A simple implementation to provide code completion will help authors writing
their literate programs. Having possible tag names suggested will help
decreasing the cognitive load of remembering all code fragment names in a
literate project. This project itself has well over 50 fragments, and having to
remember them by name is not easy.</p>
<p>Until there is a good <strong>literate</strong> file type integration with Visual Studio Code
we'll be relying on the built-in <strong>Markdown</strong> functionality.</p>
<pre><code><span class="hljs-keyword">const</span> completionItemProvider =
  vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">registerCompletionItemProvider</span>(<span class="hljs-string">&#x27;markdown&#x27;</span>, {
    &lt;&lt;implement provide completion items&gt;&gt;
}, <span class="hljs-string">&#x27;&lt;&#x27;</span>);
context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(completionItemProvider);
</code></pre>
<h3>Providing completion items</h3>
<p>The completion item provider will generate a <code>CompletionItem</code> for each fragment
we currently know of. Although the provider gets passed in the <code>TextDocument</code>
for which it was triggered we will present fragments from the entire project.</p>
<pre><code><span class="hljs-keyword">async</span> <span class="hljs-title function_">provideCompletionItems</span>(<span class="hljs-params">
  <span class="hljs-variable language_">document</span> : vscode.TextDocument,
  ..._
</span>)
{
</code></pre>
<p>After setting up the necessary variables with
<code>&lt;&lt;setup variables for providing completion items&gt;&gt;</code> we figure out to which
workspace folder the current <code>TextDocument</code>. If no workspace folder can be
determined we return an empty array. This can happen with an unsaved new file,
or when documents were opened that are not part of the workspace.</p>
<pre><code>  &lt;&lt;setup variables <span class="hljs-keyword">for</span> providing completion items&gt;&gt;
  &lt;&lt;get workspace <span class="hljs-keyword">for</span> <span class="hljs-title class_">TextDocument</span>&gt;&gt;
</code></pre>
<p>After the workspace folder has been determined we can gather all fragments in
our project.</p>
<pre><code>  &lt;&lt;get fragments <span class="hljs-keyword">for</span> completion items&gt;&gt;
</code></pre>
<p>Finally we generate the completion items into the array <code>completionItems</code> that
we return when done.</p>
<pre><code>  &lt;&lt;<span class="hljs-keyword">for</span> each fragment create a completion item&gt;&gt;
  <span class="hljs-keyword">return</span> completionItems;
}
</code></pre>
<h4>Setting up variables</h4>
<p>Completion items are going to be collected in an <code>Array&lt;CompletionItem&gt;</code>.
Further,  creating completion items for code completion needs to parse the
entire project, so we need an <code>Array&lt;GrabbedState&gt;</code>. Iterating and parsing
through the project also needs a <code>DiagnosticCollection</code>, although we won't be
using it any further. Lastly we create an instance of the <em>MarkdownIt</em> parser to
give to <code>iterateLiterateFiles</code>.</p>
<pre><code><span class="hljs-keyword">let</span> completionItems : <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">CompletionItem</span>&gt; =
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">CompletionItem</span>&gt;();
<span class="hljs-keyword">let</span> envForCompletion : <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">CompletionItem</span>&gt;();
<span class="hljs-keyword">const</span> diagnostics = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate-completionitems&#x27;</span>);
<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
</code></pre>
<h4>Workspace folder for TextDocument</h4>
<p>Determining the workspace folder for the given TextDocument is done by creating
relative paths from each workspace folder to the document. If the path does not
start with <code>..</code> we found the workspace folder where the document is from.</p>
<p>If no workspace folders were found, or if the TextDocument did not have a
workspace folder we essentially end up returning an empty array from the
completion item provider.</p>
<pre><code><span class="hljs-keyword">const</span> workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-variable language_">document</span>);
<span class="hljs-keyword">if</span>(!workspaceFolder) { <span class="hljs-keyword">return</span> []; }
</code></pre>
<h4>Retrieving fragments of project</h4>
<p>Getting the fragments for our project means we <code>iterateLiterateFiles</code>with the
<code>envForCompletion</code> given, along with the workspace folder and the <em>MarkdownIt</em>
parser. Once we have iterated over all files, and thus <code>envForCompletion</code> now
contains all literate documents tokenized we can pass those to <code>handleFragments</code>
so we can end up with a map of all fragments. We pass in <code>false</code> to the function
to ensure fragments aren't extrapolated: we want to show the fragments as they
are in code completion.</p>
<pre><code>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(workspaceFolder, <span class="hljs-literal">undefined</span>, envForCompletion, md);
  <span class="hljs-keyword">let</span> fragments = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(workspaceFolder, envForCompletion, diagnostics, <span class="hljs-literal">false</span>, writeSourceFiles);
</code></pre>
<h4>Creating the CompletionItems</h4>
<p>With all fragments in the map we iterate over all the keys. For each key we
fetch the corresponding <code>FragmentInformation</code>. Now we can create the
<code>CompletionItem</code> with the <code>fragmentName</code> as its content.</p>
<p>Further the fragment code is set to be the detail of the completion item. This
will provide a tooltip with the code fragment readable, so that it is easy to
understand what fragment is currently highlighted in the completion list.</p>
<p>Finally the set the completion item kind to <code>Reference</code> so that we get a nice
icon in the completion list pop-up.</p>
<pre><code>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>())
  {
    <span class="hljs-keyword">const</span> fragment : <span class="hljs-title class_">FragmentInformation</span> | <span class="hljs-literal">undefined</span> = fragments.<span class="hljs-title function_">get</span>(fragmentName);
    <span class="hljs-keyword">if</span>(!fragment) {
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">const</span> fragmentCompletion = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">CompletionItem</span>(fragmentName);
    fragmentCompletion.<span class="hljs-property">detail</span> = fragment.<span class="hljs-property">code</span>;
    fragmentCompletion.<span class="hljs-property">kind</span> = vscode.<span class="hljs-property">CompletionItemKind</span>.<span class="hljs-property">Reference</span>;
    completionItems.<span class="hljs-title function_">push</span>(fragmentCompletion);
  }
</code></pre>
<h2>Hover elements</h2>
<p>In addition to code completion we can provide hover information. We want to see
the implementation of fragments when hovering of fragment usages. That way code
inspection can be easier done.</p>
<p>We'll create <code>FragmentHoverProvider</code> which implements <code>HoverProvider</code>.</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentHoverProvider</span> <span class="hljs-keyword">implements</span> vscode.<span class="hljs-property">HoverProvider</span> {
  &lt;&lt;hover provider method&gt;&gt;
}
</code></pre>
<p>The <code>FragmentHoverProvider</code> implements <code>provideHover</code>. This will create the
<code>Hover</code> item if under the current cursor position there is a fragment, including
its opening and closing double chevrons.</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">provideHover</span>(<span class="hljs-params">
  <span class="hljs-variable language_">document</span> : vscode.TextDocument,
  position : vscode.Position,
  _: vscode.CancellationToken
</span>)
{
  &lt;&lt;get current line&gt;&gt;
  &lt;&lt;find workspace folder <span class="hljs-keyword">for</span> hover detection&gt;&gt;
  &lt;&lt;create hover item <span class="hljs-keyword">for</span> fragment&gt;&gt;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<p>We get the current line of text from the document. We are going to look only for
tags that are on one line. In the future it would be nice to add support for
cases where mentioning a fragment in explaining text is split over several lines
due to word wrapping, but with the current implementation we'll look only at
those that are on one line.</p>
<pre><code><span class="hljs-keyword">const</span> currentLine = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">lineAt</span>(position.<span class="hljs-property">line</span>);
</code></pre>
<p>Next we need to know the the workspace folder for the given document so that we
can query the correct project for the fragments. If no workspace folder was
determined return <code>null</code>, as there is no literate project associated with the
given document.</p>
<pre><code><span class="hljs-keyword">const</span> workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-variable language_">document</span>);
<span class="hljs-keyword">if</span>(!workspaceFolder) { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; }
</code></pre>
<p>Fragments are now available so we can see if we have a fragment under our
cursor. If we do, and the fragment is not one that defines or appends to a
fragment we know our cursor is over either fragment usage in a code fence or a
fragment mention in explaining text. For this we can create a <code>Hover</code> with the
code of the fragment as a <code>MarkdownString</code> in a code fence.</p>
<p>If that is not the case our <code>provideHover</code> implementation will return <code>null</code>.</p>
<pre><code><span class="hljs-keyword">const</span> matchesOnLine = [...currentLine.<span class="hljs-property">text</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matchesOnLine)
{
  <span class="hljs-keyword">if</span>(!match || !match.<span class="hljs-property">groups</span>) {
    <span class="hljs-keyword">continue</span>;
  }
  <span class="hljs-keyword">const</span> foundIndex = currentLine.<span class="hljs-property">text</span>.<span class="hljs-title function_">indexOf</span>(match[<span class="hljs-number">0</span>]);
  <span class="hljs-keyword">if</span>(foundIndex&gt;-<span class="hljs-number">1</span>) {
    &lt;&lt;get fragments <span class="hljs-keyword">for</span> hover detection&gt;&gt;
    <span class="hljs-keyword">if</span>(foundIndex &lt;= position.<span class="hljs-property">character</span> &amp;&amp; position.<span class="hljs-property">character</span> &lt;= foundIndex + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> &amp;&amp; fragments.<span class="hljs-title function_">has</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>))
    {
      <span class="hljs-keyword">const</span> startPosition = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(currentLine.<span class="hljs-property">lineNumber</span>, foundIndex);
      <span class="hljs-keyword">const</span> endPosition = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(currentLine.<span class="hljs-property">lineNumber</span>, foundIndex + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>);
      <span class="hljs-keyword">let</span> range : vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(startPosition, endPosition);
      <span class="hljs-keyword">let</span> fragment = fragments.<span class="hljs-title function_">get</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">tagName</span>) || <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">if</span> (fragment &amp;&amp; !match.<span class="hljs-property">groups</span>.<span class="hljs-property">root</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Hover</span>(
          <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">`~~~ <span class="hljs-subst">${fragment.lang}</span>\n<span class="hljs-subst">${fragment.code}</span>\n~~~`</span>, <span class="hljs-literal">true</span>),
          range);
      }
    }
  }
}
</code></pre>
<p>With the workspace folder in hand we can iterate over all literate files in the
workspace and get the fragments for the project. We don't want extrapolated
fragments, we want to see them as they are with fragment usages intact.</p>
<pre><code><span class="hljs-keyword">const</span> diagnostics = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate-completionitems&#x27;</span>);
<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
<span class="hljs-keyword">let</span> envForCompletion : <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;vscode.<span class="hljs-property">CompletionItem</span>&gt;();
<span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(workspaceFolder, <span class="hljs-literal">undefined</span>, envForCompletion, md);
<span class="hljs-keyword">let</span> fragments = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(workspaceFolder, envForCompletion, diagnostics, <span class="hljs-literal">false</span>, writeSourceFiles);
</code></pre>
<h2>Diagnostics</h2>
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDiagnostics</span>(<span class="hljs-params">
  uri: vscode.Uri,
  collection: vscode.DiagnosticCollection,
  diagnostic : vscode.Diagnostic | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">if</span> (uri) {
    <span class="hljs-keyword">if</span> (diagnostic) {
      <span class="hljs-keyword">const</span> diags = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(collection.<span class="hljs-title function_">get</span>(uri) || []);
      diags.<span class="hljs-title function_">push</span>(diagnostic);
      collection.<span class="hljs-title function_">set</span>(uri, diags);
    }
  } <span class="hljs-keyword">else</span> {
    collection.<span class="hljs-title function_">clear</span>();
  }
}

<span class="hljs-comment">/**
 * Create diagnostic for a given token with message.
 * <span class="hljs-doctag">@param</span> token Token that carries the faulty code fragment
 * <span class="hljs-doctag">@param</span> message Error message
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createErrorDiagnostic</span>(<span class="hljs-params">token: Token, message: <span class="hljs-built_in">string</span></span>) : vscode.<span class="hljs-property">Diagnostic</span> {
  <span class="hljs-keyword">let</span> range = <span class="hljs-title function_">fragmentRange</span>(token);
  <span class="hljs-keyword">let</span> <span class="hljs-attr">diagnostic</span>: vscode.<span class="hljs-property">Diagnostic</span> = {
    <span class="hljs-attr">severity</span>: vscode.<span class="hljs-property">DiagnosticSeverity</span>.<span class="hljs-property">Error</span>,
    <span class="hljs-attr">message</span>: message,
    <span class="hljs-attr">range</span>: range
  };

  <span class="hljs-keyword">return</span> diagnostic;
}

<span class="hljs-comment">/**
 * Give the location of the line in the Markup document that contains the
 * tag declaration.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragment</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>]) : -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> linenumber;
}

<span class="hljs-comment">/**
 * Give the location of the last line in the Markup document that contains the
 * code fragment.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragmentEnd</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>] ) : -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> linenumber;
}


<span class="hljs-comment">/**
 * Give range for the code fragment, including tag.
 * <span class="hljs-doctag">@param</span> token Token to create range for
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fragmentRange</span>(<span class="hljs-params">token: Token</span>): vscode.<span class="hljs-property">Range</span> {
  <span class="hljs-keyword">let</span> startTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>) + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">let</span> endTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>) - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragment</span>(token), startTagName);
  <span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragmentEnd</span>(token), endTagName);
  <span class="hljs-keyword">let</span> <span class="hljs-attr">range</span>: vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(start, end);
  <span class="hljs-keyword">return</span> range;
}
</code></pre>
<h2>The extension</h2>
<p>Our Visual Studio Code entry file is the <code>extension.ts</code> file. While developing
the plug-in the JavaScript version created from this, in <code>out/extension.js</code> is
set as the entry point for the extension, in <code>package.json</code>. But when it is
prepared for release on the Visual Studio Code marketplace this needs to be
changed to the minified and bundled version that gets realized as <code>out/main.js</code>.
This ensures, together with a properly set up <code>.vscodeignore</code> that the published
package stays small in size. Without that the package is easily over 2MB in
size, but properly configured it is under 400KB.</p>
<p>The extension main entry lies in the activation of the extension, as given by
<code>&lt;&lt;activate the extension&gt;&gt;</code>, but before we get there we need to set up several
bits and pieces that are required for the proper functioning of the tools.</p>
<p>First of all we import all the functionality and modules we are going to need.</p>
<pre><code><span class="hljs-comment">/* Literate Programming by Nathan &#x27;jesterKing&#x27; Letwory */</span>

&lt;&lt;<span class="hljs-keyword">import</span> necessary modules <span class="hljs-keyword">for</span> literate&gt;&gt;
</code></pre>
<p>After the imports we introduce the <code>oldFence</code> where we will keep a hold of the
fence rule from the default <em>MarkdownIt</em> parser. I was not entirely sure how to
best tackle it, so for now it is here.</p>
<pre><code><span class="hljs-keyword">let</span> oldFence : <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">RenderRule</span> | <span class="hljs-literal">undefined</span>;
</code></pre>
<p>With that out of the way we introduce the interfaces we use in the Literate
Programming extension.</p>
<pre><code>&lt;&lt;introduce interfaces&gt;&gt;

</code></pre>
<p>Next we set up the fragment regular expressions and define everything needed to
implement the fragment explorer. This explorer will show up in the Explorer bar
when a literate project is open. We need a representation for a node in the tree
view, a data provider for the tree view and then the actual tree view explorer
itself.</p>
<pre><code>&lt;&lt;fragment regular expressions&gt;&gt;

&lt;&lt;fragment node&gt;&gt;

&lt;&lt;fragment tree provider&gt;&gt;

&lt;&lt;fragment explorer&gt;&gt;

&lt;&lt;fragment hover provider&gt;&gt;
</code></pre>
<p>For our extension we need to override the code fence rule since we want to
augment the rendering of the code fences. Specifically we want to add the
fragment line prior to the code block. This is explained in the section on
<code>&lt;&lt;renderCodeFence rule&gt;&gt;</code>.</p>
<p>Also we have a way to create a <em>MarkdownIt</em> parser the way we need it. It is
explained in more detail in the section on <code>&lt;&lt;create markdownit parser&gt;&gt;</code>.</p>
<pre><code>&lt;&lt;renderCodeFence rule&gt;&gt;

&lt;&lt;create markdownit parser&gt;&gt;

</code></pre>
<p>The central mechanism of the <strong>Literate Programming</strong> extension, the tools it
provides, are expressed in <code>&lt;&lt;render and collect state&gt;&gt;</code>,
<code>&lt;&lt;handle fragments&gt;&gt;</code> and <code>&lt;&lt;write out source files&gt;&gt;</code>. These all ensure that
all <strong>literate</strong> files can be iterated, parsed, rendered. And that from the
parsed state all the code fragments can be collected and extrapolated into the
source file or source files as written in the <strong>literate</strong> program.</p>
<pre><code>&lt;&lt;render and collect state&gt;&gt;
&lt;&lt;handle fragments&gt;&gt;
&lt;&lt;write out source files&gt;&gt;
</code></pre>
<p>Utility function to determine the workspace folder for a TextDocument</p>
<pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">determineWorkspaceFolder</span>(<span class="hljs-params"><span class="hljs-variable language_">document</span> : vscode.TextDocument</span>) : vscode.<span class="hljs-property">WorkspaceFolder</span> | <span class="hljs-literal">undefined</span>
{
  <span class="hljs-keyword">if</span>(!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> || vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>)
  {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> ws <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>)
  {
    <span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(ws.<span class="hljs-property">uri</span>.<span class="hljs-title function_">toString</span>(), <span class="hljs-variable language_">document</span>.<span class="hljs-property">uri</span>.<span class="hljs-title function_">toString</span>());
    <span class="hljs-keyword">if</span>(!relativePath.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;..&#x27;</span>))
    {
      <span class="hljs-keyword">return</span> ws;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}
</code></pre>
<p>Although the fragments mentioned above are the soul of the extension they are
not of much use without the proper activation. With this <code>activate</code>
implementation all providers and commands are registered with Visual Studio
Code.</p>
<pre><code>&lt;&lt;activate the extension&gt;&gt;
</code></pre>
<pre><code>&lt;&lt;diagnostic updating&gt;&gt;
</code></pre>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deactivate</span>(<span class="hljs-params"></span>) {}
</code></pre>
<h3>The imports</h3>
<pre><code><span class="hljs-keyword">import</span> { <span class="hljs-title class_">TextDecoder</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;util&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> vscode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vscode&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">StateCore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/rules_core/state_core&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Token</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/token&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;markdown-it&quot;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Renderer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/renderer&#x27;</span>);

<span class="hljs-comment">// `import` here fails so instead we require the highlight module</span>
<span class="hljs-comment">// this way. Not sure why import fails. It would be great to find</span>
<span class="hljs-comment">// out the reason.</span>
<span class="hljs-keyword">const</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;highlight.js&#x27;</span>);

<span class="hljs-keyword">import</span> { grabberPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./grabber&#x27;</span>;
</code></pre>
<h3>Interfaces used in Literate Programming</h3>
<pre><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WriteRenderCallback</span> {
  (
    fname : <span class="hljs-built_in">string</span>,
    folderUri : vscode.<span class="hljs-property">Uri</span>,
    content : <span class="hljs-built_in">string</span>
  ) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt;
};
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">WriteSourceCallback</span> {
  (
    workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>,
    fragments : <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;
  ) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt;
};

&lt;&lt;grabbed state <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;fragment information <span class="hljs-keyword">type</span>&gt;&gt;
</code></pre>
<h3>Extension activation</h3>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>) {
  <span class="hljs-keyword">const</span> rootPath = (vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> &amp;&amp; (vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>))
    ? vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>[<span class="hljs-number">0</span>].<span class="hljs-property">uri</span>.<span class="hljs-property">fsPath</span> : <span class="hljs-literal">undefined</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ready to do some Literate Programming&#x27;</span>);
  <span class="hljs-keyword">const</span> diagnostics = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate&#x27;</span>);

  &lt;&lt;register literate.<span class="hljs-property">process</span>&gt;&gt;
  &lt;&lt;register fragment tree view&gt;&gt;
  &lt;&lt;register completion item provider&gt;&gt;

  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(
    vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">registerHoverProvider</span>(<span class="hljs-string">&#x27;markdown&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentHoverProvider</span>())
  );

  <span class="hljs-keyword">if</span> (vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>) {
    <span class="hljs-title function_">updateDiagnostics</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
  }
  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">onDidChangeActiveTextEditor</span>(<span class="hljs-function"><span class="hljs-params">editor</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (editor) {
      <span class="hljs-title function_">updateDiagnostics</span>(editor.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
    }
  }));

  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(literateProcessDisposable);
  context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-title function_">onDidChangeTextDocument</span>(
    <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
      vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">executeCommand</span>(<span class="hljs-string">&#x27;literate.process&#x27;</span>);
    }
  ));

  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">extendMarkdownIt</span>(<span class="hljs-params">md: <span class="hljs-built_in">any</span></span>) {
      md.<span class="hljs-title function_">use</span>(grabberPlugin);
      oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
      md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
      <span class="hljs-keyword">return</span> md;
    }
  };
};
</code></pre>
<h2>Afterword</h2>
<p>So you have made it this far - or perhaps you just skipped over a lot of text.
If you actually read all the text up to this point you have read also all of the
code for the entire <strong>Literate Programming</strong>. I appreciate you took the time to
read this document. I hope it helped you get more interested in the <strong>literate
programming</strong> paradigm.</p>
<p>I invite you to install the <strong>Literate Programming</strong> extension for Visual Studio
Code and start using it in your daily work.</p>

    </body>
  </html>
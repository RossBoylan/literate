<html>
		<head>
			<link rel="stylesheet" type="text/css" href="./style.css">
		</head>
		<body>
		<h1>Literate Programming</h1>
<p><strong>Literate programming</strong> is a programming paradigm introduced by Donald Knuth. A
program is written in a natural language with snippets of code interspersed.
From this text usable source code is generated, along with well formatted
human-readable document.</p>
<p>The most important influence for this <strong>literate programming</strong> extension is the
<a href="https://pbr-book.org">PBR Book</a>.</p>
<p>This extension provides a set of tools that help the programmer writing literate
programs. Snippets in this extension are called code fragments.</p>
<p>The approach for this extension is based on Markdown documents. The Markdown
specification is only slightly adapted to make supporting <strong>literate
programming</strong> easy. The code fragments are expressed in code fences as per the
Markdown specification, either with surrounding tripple backticks or tripple
tildes. Along with the programming language identifier the opening line has been
extended to contain the fragment name and type as essentially options to the
code fence. This opening line thus will look like <code>py : &lt;&lt;fragment name&gt;&gt;</code> to
create a new fragment, or like <code>py : &lt;&lt;fragment name&gt;&gt;=+</code> to amend an existing
fragment.</p>
<p>To create actual source files a fragment creation line needs to be used with a
slightly extended form of the creation tag mentioned above. The name has to be
postixed with the string <code>.*</code> betueen the angle brackets. Furthermore a file
name needs to be specied after the equal sign. This is essentially a relative
path that is going to be appended each workspace folder as the root. A top level
fragment looks like <code>py : &lt;&lt;top-level fragment.*&gt;&gt; ./src/source.py</code>. The
name of this fragment is <code>top-level fragment</code>, and once it has been fully
extrapolated will be written to a file in the workspace folder under <code>src</code> as
the file <code>source.py</code>.</p>
<h2>Iterating all literate files</h2>
<p>The main idea of the extension is to collect all fragments that are created in
all <code>.literate</code> files.</p>
<p>Once all fragments have been collected they are expanded such that eventually
there will be only the top fragments. A top fragment specifies a file to which
it will be written.</p>
<p>The first step is to put each <code>.literate</code> file through the <em>MarkdownIt</em> renderer.
Each rendering will be given a special environment that will be used to collect
the state for the render. The state will contain all the tokens as recognized by
the renderer. The state <code>env</code> is of type <code>GrabbedState</code>, and used to collect the
tokens generated by <em>MarkdownIt</em> parser. The tokens are needed to find all the
fragments for our programs. For each <code>.literate</code> file the grabbed state <code>env</code> is
saved in the list of <code>GrabbedState</code>s <code>envList</code>.</p>
<p>Each rendered file will be saved as a <code>HTML</code> file with the same name
as the <code>.literate</code> file that was being rendered, but with the extension replaced
with <code>.html</code>. This will be handled by the <code>WriteRenderCallback</code> if one is passed
to <code>iterateLiterateFiles</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;render and collect state&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">iterateLiterateFiles</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder, writeHtml : WriteRenderCallback | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>, envList : <span class="hljs-built_in">Array</span>&lt;GrabbedState&gt;, md : MarkdownIt</span>)
{
	<span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
	<span class="hljs-keyword">const</span> sourceUri = folderUri;
	<span class="hljs-keyword">const</span> literateFilesInWorkspace : vscode.<span class="hljs-property">RelativePattern</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">RelativePattern</span>(workspaceFolder, <span class="hljs-string">&#x27;**/*.literate&#x27;</span>);

	<span class="hljs-comment">/** All .literate files found in our workspace */</span>
	<span class="hljs-keyword">const</span> foundLiterateFiles = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>
		.<span class="hljs-title function_">findFiles</span>(literateFilesInWorkspace)
		.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">files</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file)));

	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fl <span class="hljs-keyword">of</span> foundLiterateFiles) {
			<span class="hljs-keyword">const</span> uri = vscode.<span class="hljs-property">Uri</span>.<span class="hljs-title function_">file</span>(fl.<span class="hljs-property">path</span>);
			<span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">readFile</span>(uri);
			<span class="hljs-keyword">let</span> fname = fl.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(folderUri.<span class="hljs-property">path</span>, <span class="hljs-string">&#x27;&#x27;</span>);
			<span class="hljs-comment">/** Environment where we can grab the state. */</span>
			<span class="hljs-keyword">const</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span> = { <span class="hljs-attr">literateFileName</span>: fname, <span class="hljs-attr">literateUri</span>: uri, <span class="hljs-attr">gstate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCore</span>(<span class="hljs-string">&#x27;&#x27;</span>, md, {}) };
			<span class="hljs-keyword">const</span> text = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>).<span class="hljs-title function_">decode</span>(content);
			envList.<span class="hljs-title function_">push</span>(env);
			<span class="hljs-keyword">const</span> rendered = md.<span class="hljs-title function_">render</span>(text, env);
			<span class="hljs-keyword">if</span>(writeHtml)
			{
				<span class="hljs-keyword">await</span> <span class="hljs-title function_">writeHtml</span>(fname, folderUri, sourceUri, rendered);
			}
		}
	} <span class="hljs-keyword">catch</span> (error) {
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);
	}
}
</code></pre>
</div></div><h3>GrabbedState interface</h3>
<p>The <code>GrabbedState</code> interface is used to create a type that helps us collecting
the tokens for each <code>.literate</code> file. Instances of objects with this interface
are passed to a <em>MarkdownIt</em> renderer. The renderer will have the
<code>GrabberPlugin</code> registered. This provides a rule that helps us collecting the
states of each rendered file. The grabbed state is collected in <code>gstate</code>, which
is an instance of the <code>StateCore</code>, provided by <em>MarkdownIt</em>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;grabbed state type&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
 * Interface for environment to hold the Markdown file name and the StateCore
 * grabbed by the grabberPlugin.
 * The gstate we use to access all the tokens generated by the MarkdownIt parser.
 *
 * <span class="hljs-doctag">@see</span> <span class="hljs-variable">StateCore</span>
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">GrabbedState</span> {
	<span class="hljs-comment">/**
	 * File name of the Markdown document to which the state belongs.
	 */</span>
	<span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Uri for the Markdown document.
	 */</span>
	<span class="hljs-attr">literateUri</span>: vscode.<span class="hljs-property">Uri</span>;
	<span class="hljs-comment">/**
	 * State grabbed from the MarkdownIt parser.
	 */</span>
	<span class="hljs-attr">gstate</span>: <span class="hljs-title class_">StateCore</span>;
}
</code></pre>
</div></div><h2>Preparing MarkdownIt</h2>
<p>We set up the <em>MarkdownIt</em> for our purposes. The highlight function we use to
ensure our code fragments get syntax highlighting. This simply relies on
<em>highlight.js</em> to do the work.</p>
<p>We also tell <em>MarkdownIt</em> to use our <code>grabberPlugin</code>. This plug-in harvests the
internal states for each document into instances of <code>GrabbedState</code>. These states
we'll later use to get all the different code fragments and to weave them into
the code files they describe.</p>
<p>Finally we replace the default <code>fence</code> rule with our own <code>renderCodeFence</code> rule.
The intent of that rule will be explained in the section on <code>renderCodeFence</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;set up MarkdownIt&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
	* MarkdownIt instance with grabber_plugin in use.
	*/</span>
<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
</code></pre>
</div></div><h2>Fragment structure and regular expressions</h2>
<p>Before we dive deeper into the processing of <code>.literate</code> documents it is
necessary to have a look at how fragments work.</p>
<p>Fragments in the <code>literate</code> extension have a specific format that requires a bit
of explaining.</p>
<p>There are four types of fragment tags, three of which either create or modify a
fragment, and one that expresses fragment usage.</p>
<p>For the detection of fragments a couple of regular expressions are used. These
are explained in more detail below.</p>
<h3>Fragment use in code</h3>
<p>Lets start by looking at the form for fragment tag use.</p>
<p>Fragments can be used in code blocks by using their tag double opening and
closing chevrons around the fragment name <code>&lt;&lt;fragment name&gt;&gt;</code>. To detect usage
of fragments in code we use <code>FRAGMENT_USE_IN_CODE_RE</code>.</p>
<p>The regular expression captures four groups. A match will give us 5 or more
results, the whole string matched and the groups. There may be some additional
parts after that, but those we will discard. The whole string matched is called
the <code>tag</code>. The first group is called <code>indent</code>, which will be used to indent the
whole fragment code when it gets extrapolated into the final code. The second
group is called <code>tagName</code>, which is the fragment name. The third group is called
<code>root</code> and the final group is called <code>add</code>. For fragment use we essentially need
only the second group <code>tagName</code>, with the <code>indent</code> still serving a function. The
other groups are in the regular expression so we can identify incorrect use of
fragments in code: creating or adding to fragments inside code blocks is not
valid.</p>
<p>The application of <code>FRAGMENT_USE_IN_CODE_RE</code> is explained in more detail in the
section on code realization.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment regular expressions&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">//let HTML_ENCODED_FRAGMENT_TAG_RE = /(&amp;lt;&amp;lt.*?&amp;gt;&amp;gt;)/g;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span> = <span class="hljs-regexp">/([ \t]*)&lt;&lt;(.*)&gt;&gt;(=)?(\+)?/g</span>;
</code></pre>
</div></div><h3>Creating and modifying fragments</h3>
<p>There is the tag used to create a new fragment, which is always in conjunction
with the opening code fence tag. This means either a triple backtick or triple
tilde followed by the programming language identifier for the following code
block. The actual fragment tag is placed as first option right after the color
following the language specifier.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment regular expressions&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">FRAGMENT_RE</span> = <span class="hljs-regexp">/(.*):.*&lt;&lt;(.*)&gt;&gt;(=)?(\+)?\s*(.*)/</span>;
</code></pre>
</div></div><p>Most of the groups correspond to the ones defined by <code>FRAGMENT_USE_IN_CODE_RE</code>
with a few additions. Most notably there is the group catching the language
specifier, and the group to catch the filename, called <code>lang</code> and <code>fileName</code>
respectively.</p>
<p>So to create a new tag the info line for the code fence could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=</code>.</p>
<p>To add to a fragment a <code>+</code> is added, so it could look like
<code>py : &lt;&lt;a fragment name&gt;&gt;=+</code>. Having a fragment without <code>=</code> or <code>=+</code> on the code
fence info line is an error.</p>
<h2>Gathering all fragments</h2>
<p>All code fragments are fetched from each environment state. This is done through
looking for all <code>fence</code> tokens. If the <code>token.info</code> for a <code>fence</code> matches the
<code>FRAGMENT_RE</code> we can check to see whether the fragment we have currently in our
hands is a new fragment (<code>root &amp;&amp; !add</code>) or whether this one expands an existing
one (<code>root &amp;&amp; add</code>), as will be explained in more detail further down.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;handle fragments&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleFragments</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder, envList : <span class="hljs-built_in">Array</span>&lt;GrabbedState&gt;, diagnostics : vscode.DiagnosticCollection, extrapolateFragments : <span class="hljs-built_in">boolean</span>, writeSource : WriteSourceCallback | <span class="hljs-literal">undefined</span></span>) : <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;&gt;
{
	<span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
	<span class="hljs-keyword">const</span> sourceUri = folderUri;
	&lt;&lt;build fragment map&gt;&gt;

	<span class="hljs-keyword">if</span>(extrapolateFragments)
	{
		&lt;&lt;extrapolate fragments&gt;&gt;
	}

	<span class="hljs-keyword">if</span>(writeSource) {
		<span class="hljs-title function_">writeSource</span>(workspaceFolder, fragments);
	}

	<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(fragments);
}
</code></pre>
</div></div><div class="codefragment"><div class="fragmentname">&lt;&lt;write out source files&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">writeSourceFiles</span>(<span class="hljs-params">workspaceFolder : vscode.WorkspaceFolder, fragments : <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, FragmentInformation&gt;</span>)
{
	<span class="hljs-keyword">const</span> folderUri = workspaceFolder.<span class="hljs-property">uri</span>;
	<span class="hljs-keyword">const</span> sourceUri = folderUri;
	<span class="hljs-comment">/* now write out the source files. */</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
		<span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
			<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
			<span class="hljs-keyword">if</span> (fragmentInfo) {
				<span class="hljs-keyword">let</span> fileName = fragmentInfo.<span class="hljs-property">sourceFileName</span>.<span class="hljs-title function_">trim</span>();
				<span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(fragmentInfo.<span class="hljs-property">code</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
				<span class="hljs-keyword">const</span> fileUri = folderUri.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">path</span>: path.<span class="hljs-property">posix</span>.<span class="hljs-title function_">join</span>(sourceUri.<span class="hljs-property">path</span>, fileName) });
				<span class="hljs-keyword">await</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded);
			}
		}
	}
}
</code></pre>
</div></div><h3>Populating the fragment map</h3>
<p>First we build a map of all available fragments. These will go into <code>fragments</code>,
which is of type <code>Map&lt;string, FragmentInformation&gt;</code>. The name of a fragment will
function as the key, and an instance of <code>FragmentInformation</code> will be the value.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;build fragment map&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
 * Map of fragment names and tuples of code fragments for these. The
 * tuples contain code language identifier followed by the filename and
 * lastly followed by the actual code fragment.
 */</span>
<span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;();
<span class="hljs-comment">// Now we have the state, we have access to the tokens</span>
<span class="hljs-comment">// over which we can iterate to extract all the code</span>
<span class="hljs-comment">// fragments and build up the map with the fragments concatenated</span>
<span class="hljs-comment">// where necessary. We&#x27;ll extrapolate all fragments in the second</span>
<span class="hljs-comment">// pass.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> env <span class="hljs-keyword">of</span> envList) {
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> token <span class="hljs-keyword">of</span> env.<span class="hljs-property">gstate</span>.<span class="hljs-property">tokens</span>) {
		&lt;&lt;handle fence tokens&gt;&gt;
	}
}
</code></pre>
</div></div><p>Each <code>fence</code> token we find we need to check. There may be of course code fences
in the document that do not create or modify a fragment. These we need to skip.</p>
<p>Since we are handling code fences we use <code>FRAGMENT_RE</code> to match <code>token.info</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;handle fence tokens&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fence&#x27;</span>) {
	<span class="hljs-keyword">const</span> linenumber = <span class="hljs-title function_">locationOfFragment</span>(token);
	<span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
	<span class="hljs-keyword">if</span> (match) {
		<span class="hljs-keyword">let</span> [_, lang, name, root, add, fileName, ...__] = match;
		lang = lang.<span class="hljs-title function_">trim</span>();
		&lt;&lt;add to existing fragment&gt;&gt;
		&lt;&lt;create a <span class="hljs-keyword">new</span> fragment&gt;&gt;
	}
}
</code></pre>
</div></div><h3>Creating a new fragment</h3>
<p>If the <code>root</code> group has captured a result, but the <code>add</code> group not we know we
have a new fragment on our hand.</p>
<p>If we already have in our <code>fragments</code> map a key with the same <code>name</code> as the
fragment we are currently handling we add an error diagnostic message. We don't
stop handling fences, or the entire <code>literate.process</code> command for that matter.
We keep on going, but leave it up to the programmer to see and handle the error
messages.</p>
<p>If a fragment name with <code>.*</code> is found we need to ensure there is a result in the
<code>fileName</code> capture group. That is going to be needed to write out the source
code file eventually. A file defining fragment without a file name is an error.</p>
<p>When everything appears to be in order a new <code>FragmentInformation</code> instance is
created with the information found. The code for this fragment is the token
content in <code>token.content</code>. Finally the new <code>FragmentInformation</code> instance is
added to the <code>fragments</code> map.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;create a new fragment&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; !add) {
	<span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
		<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to overwrite existing fragment fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span><span class="hljs-subst">${linenumber}</span>`</span>;
		<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
		<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (!fileName &amp;&amp; name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt; -<span class="hljs-number">1</span>) {
			<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Expected filename for star fragment <span class="hljs-subst">${name}</span>`</span>;
			<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
			<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">let</span> code = token.<span class="hljs-property">content</span>;
			<span class="hljs-keyword">let</span> <span class="hljs-attr">fragmentInfo</span>: <span class="hljs-title class_">FragmentInformation</span> = {
				<span class="hljs-attr">lang</span>: lang,
				<span class="hljs-attr">literateFileName</span>: env.<span class="hljs-property">literateFileName</span>,
				<span class="hljs-attr">sourceFileName</span>: fileName,
				<span class="hljs-attr">code</span>: code,
				<span class="hljs-attr">tokens</span>: [token],
				<span class="hljs-attr">env</span>: env,
			};
			fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
		}
	}
}
</code></pre>
</div></div><h3>Modifying an exiting fragment</h3>
<p>If both the <code>root</code> and <code>add</code> groups have capture their results, an <code>=</code> and an
<code>+</code> respectively we need to add code to an existing fragment.</p>
<p>For this to work a new fragment needs to be always present before the modifying
fragment. It is an error to try to modify a fragment that hasn't been seen yet.</p>
<p>The fragment with specified <code>name</code> is fetched, and when it is not <code>undefined</code>
the <code>token.content</code> is appended to the <code>code</code> of the <code>FragmentInformation</code>
instance we got from the map. The current token is also appended to the <code>tokens</code>
list.</p>
<p>The fragments map is updated with the modified  <code>FragmentInformation</code> instance.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;add to existing fragment&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span> (root &amp;&amp; add) {
	<span class="hljs-keyword">if</span> (fragments.<span class="hljs-title function_">has</span>(name)) {
		<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(name) || <span class="hljs-literal">undefined</span>;
		<span class="hljs-keyword">if</span>(fragmentInfo &amp;&amp; fragmentInfo.<span class="hljs-property">code</span>) {
			<span class="hljs-keyword">let</span> additionalCode = token.<span class="hljs-property">content</span>;
			fragmentInfo.<span class="hljs-property">code</span> = <span class="hljs-string">`<span class="hljs-subst">${fragmentInfo.code}</span><span class="hljs-subst">${additionalCode}</span>`</span>;
			fragmentInfo.<span class="hljs-property">tokens</span>.<span class="hljs-title function_">push</span>(token);
			fragments.<span class="hljs-title function_">set</span>(name, fragmentInfo);
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Trying to add to non-existant fragment <span class="hljs-subst">${name}</span>. <span class="hljs-subst">${env.literateFileName}</span>:<span class="hljs-subst">${linenumber}</span>`</span>;
		<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(token, msg);
		<span class="hljs-title function_">updateDiagnostics</span>(env.<span class="hljs-property">literateUri</span>, diagnostics, diag);
	}
}
</code></pre>
</div></div><h3>The FragmentInformation type</h3>
<p>We have now seen the <code>FragmentInformation</code> type being used several times, so it
is important to take a moment to clarify it in more detail.</p>
<p>The interface allows us to gather information for each found code fragment. It
allows us to store the programming language identifier, name of the <code>.literate</code>
file and name of the targeted source file, if the code fragment happens to be a
top fragment.</p>
<p>The actual code for the fragment is stored in <code>code</code>. Furthermore the tokens for
the complete fragment are stored in the <code>tokens</code> list. This list is of objects
that fullfill the <code>Token</code> interface, which is provided by the <em>MarkdownIt</em>
module.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment information type&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">/**
 * Interface denoting a fragment and related information
 */</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FragmentInformation</span> {
	<span class="hljs-comment">/**
	 * Programming language identifier for fragment.
	 */</span>
	<span class="hljs-attr">lang</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Filename of literate file.
	 */</span>
	<span class="hljs-attr">literateFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * Filename of target source file. This is set when the fragment
	 * is a top fragment.
	 */</span>
	<span class="hljs-attr">sourceFileName</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * The code fragment.
	 */</span>
	<span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>;
	<span class="hljs-comment">/**
	 * List of tokens that make up the entire code fragment.
	 */</span>
	<span class="hljs-attr">tokens</span>: <span class="hljs-title class_">Token</span>[];
	<span class="hljs-comment">/**
	 * The GrabbedState related to this fragment.
	 */</span>
	<span class="hljs-attr">env</span>: <span class="hljs-title class_">GrabbedState</span>;
}
</code></pre>
</div></div><h2>Extrapolating fragments</h2>
<p>Once all fragments have been collected from the <code>.literate</code> files of the project
fragments can be combined into source code.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;extrapolate fragments&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">// for now do several passes</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pass</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">do</span> {
	pass++;
	<span class="hljs-keyword">let</span> fragmentReplaced = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>()) {
		<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
		<span class="hljs-keyword">if</span> (!fragmentInfo) {
			<span class="hljs-keyword">continue</span>;
		}

		<span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
			<span class="hljs-keyword">let</span> [tag, indent, tagName, root, add, ...rest] = match;
			<span class="hljs-keyword">if</span> (root) {
				<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;=&#x27;: incorrect fragment tag in fragment, <span class="hljs-subst">${tag}</span>`</span>;
				<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
				<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
			}
			<span class="hljs-keyword">if</span> (add) {
				<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Found &#x27;+&#x27;: incorrect fragment tag in fragment: <span class="hljs-subst">${tag}</span>`</span>;
				<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
				<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
			}
			<span class="hljs-keyword">if</span> (!fragments.<span class="hljs-title function_">has</span>(tagName) &amp;&amp; tagName !== <span class="hljs-string">&quot;(.*)&quot;</span>) {
				<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Could not find fragment <span class="hljs-subst">${tag}</span> (<span class="hljs-subst">${tagName}</span>)`</span>;
				<span class="hljs-keyword">const</span> diag = <span class="hljs-title function_">createErrorDiagnostic</span>(fragmentInfo.<span class="hljs-property">tokens</span>[<span class="hljs-number">0</span>], msg);
				<span class="hljs-title function_">updateDiagnostics</span>(fragmentInfo.<span class="hljs-property">env</span>.<span class="hljs-property">literateUri</span>, diagnostics, diag);
			}
			<span class="hljs-keyword">let</span> fragmentToReplaceWith = fragments.<span class="hljs-title function_">get</span>(tagName) || <span class="hljs-literal">undefined</span>;
			<span class="hljs-keyword">if</span> (fragmentToReplaceWith) {
				<span class="hljs-keyword">let</span> code = fragmentToReplaceWith.<span class="hljs-property">code</span>;
				<span class="hljs-keyword">let</span> lines = code.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
				<span class="hljs-keyword">let</span> indentedLines = lines.<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e, _</span>) {
					<span class="hljs-keyword">return</span> indent + e;

				});
				<span class="hljs-keyword">let</span> newcode = indentedLines.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
				fragmentReplaced = <span class="hljs-literal">true</span>;
				fragmentInfo.<span class="hljs-property">code</span> = fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">replace</span>(tag, newcode);
				fragments.<span class="hljs-title function_">set</span>(fragmentName, fragmentInfo);
			}
		}
	}
	<span class="hljs-keyword">if</span>(!fragmentReplaced) {
		<span class="hljs-keyword">break</span>;
	}
}
<span class="hljs-keyword">while</span> (pass &lt; <span class="hljs-number">25</span>);
</code></pre>
</div></div><h2>custom code fence rendering</h2>
<p>Our extension uses a custom code fence rendering rule to ensure the code
fragment name is also rendered as part of the fence.</p>
<p>Essentially the old, default rendering rule for fences is first used to create
the original fence.</p>
<p>Then the <code>token.info</code> is matched against the <code>FRAGMENT_RE</code> regular expression.
If we have a match we prepare the <code>HTML</code> code to essentially wrap around the
<code>HTML</code> as generated by the default rule.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;renderCodeFence rule&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderCodeFence</span>(<span class="hljs-params">tokens : Token[], idx : <span class="hljs-built_in">number</span>, options : MarkdownIt.Options, env : <span class="hljs-built_in">any</span>, slf : Renderer</span>) {
	<span class="hljs-keyword">let</span> rendered = <span class="hljs-string">&#x27;&#x27;</span>;
	<span class="hljs-keyword">if</span> (oldFence) {
		rendered = <span class="hljs-title function_">oldFence</span>(tokens, idx, options, env, slf);

		<span class="hljs-keyword">let</span> token = tokens[idx];
		<span class="hljs-keyword">if</span> (token.<span class="hljs-property">info</span>) {
			<span class="hljs-keyword">const</span> match = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">FRAGMENT_RE</span>);
			<span class="hljs-keyword">if</span> (match) {
				<span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/naming-convention</span>
				<span class="hljs-keyword">let</span> [_, lang, name, root, add, __, ...___] = match;
				lang = lang.<span class="hljs-title function_">trim</span>();
				<span class="hljs-keyword">if</span> (name) {
					root = root || <span class="hljs-string">&#x27;&#x27;</span>;
					add = add || <span class="hljs-string">&#x27;&#x27;</span>;
					rendered = <span class="hljs-string">`&lt;div class=&quot;codefragment&quot;&gt;&lt;div class=&quot;fragmentname&quot;&gt;&amp;lt;&amp;lt;<span class="hljs-subst">${name}</span>&amp;gt;&amp;gt;<span class="hljs-subst">${root}</span><span class="hljs-subst">${add}</span>&lt;/div&gt;&lt;div class=&quot;code&quot;&gt;<span class="hljs-subst">${rendered}</span>&lt;/div&gt;&lt;/div&gt;`</span>;
					<span class="hljs-comment">//rendered = rendered.replaceAll(HTML_ENCODED_FRAGMENT_TAG_RE, codeFragmentCleanup);</span>
				}
			}
		}
	}

	<span class="hljs-keyword">return</span> rendered;
};
</code></pre>
</div></div><h2>Register the literate.process command</h2>
<p>The command <code>literate.process</code> is registered with Visual Studio Code. The
disposable that gets returned by <code>registerCommand</code> is held in
<code>literateProcessDisposable</code> so that it can be used later on, for instance for
diagnostics management.</p>
<p>Here we find the main program of our <code>literate.process</code> command. Our
<em>MarkdownIt</em> is set up, <code>.literate</code> files are searched and iterated. Each
<code>.literate</code> file is rendered, and code fragments are harvested. Finally code
fragments are extrapolated and saved to their respective source code files. The
<code>HTML</code> files are also saved to files.</p>
<p>Diagnostic messages are also handled here. Errors and warnings are shown where
necessary. On successfull completion a simple status bar message will be used.
An information diagnostic message is not good here, because that will prevent
the usage of <code>literate.process</code> in for instance <code>tasks.json</code>, since the
diagnostic message will block execution of a task if it were used as prelaunch
task. That is obviously not good for the workflow.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;register literate.process&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-comment">// The command has been defined in the package.json file</span>
<span class="hljs-comment">// Now provide the implementation of the command with registerCommand</span>
<span class="hljs-comment">// The commandId parameter must match the command field in package.json</span>
<span class="hljs-keyword">let</span> literateProcessDisposable = vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(<span class="hljs-string">&#x27;literate.process&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {

	&lt;&lt;set up <span class="hljs-title class_">MarkdownIt</span>&gt;&gt;

	diagnostics.<span class="hljs-title function_">clear</span>();

	<span class="hljs-keyword">if</span> (!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>) {
		<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&quot;No workspace or folder opened&quot;</span>);
	}


	<span class="hljs-keyword">const</span> writeOutHtml : <span class="hljs-title class_">WriteRenderCallback</span> = (fname : <span class="hljs-built_in">string</span>, folderUri : vscode.<span class="hljs-property">Uri</span>, sourceUri : vscode.<span class="hljs-property">Uri</span>, rendered : <span class="hljs-built_in">string</span>) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
		<span class="hljs-keyword">const</span> html =
<span class="hljs-string">`&lt;html&gt;
	&lt;head&gt;
		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;&gt;
	&lt;/head&gt;
	&lt;body&gt;
	<span class="hljs-subst">${rendered}</span>
	&lt;/body&gt;
&lt;/html&gt;`</span>;
		<span class="hljs-keyword">const</span> encoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(html, <span class="hljs-string">&#x27;utf-8&#x27;</span>);
		fname = fname.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.literate&quot;</span>, <span class="hljs-string">&quot;.html&quot;</span>);
		<span class="hljs-keyword">const</span> fileUri = folderUri.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">path</span>: path.<span class="hljs-property">posix</span>.<span class="hljs-title function_">join</span>(sourceUri.<span class="hljs-property">path</span>, fname) });
		<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">writeFile</span>(fileUri, encoded));
	};

	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> workspaceFolder <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>) {
		<span class="hljs-keyword">const</span> <span class="hljs-attr">envList</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
		<span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(workspaceFolder, writeOutHtml, envList, md);
        <span class="hljs-keyword">let</span> _ = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(workspaceFolder, envList, diagnostics, <span class="hljs-literal">true</span>, writeSourceFiles);
	}

	<span class="hljs-keyword">let</span> hasAnyDiagnostics = <span class="hljs-literal">false</span>;
	diagnostics.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">_: vscode.Uri, diags: <span class="hljs-keyword">readonly</span> vscode.Diagnostic[], __: vscode.DiagnosticCollection</span>) : <span class="hljs-built_in">any</span> {
		hasAnyDiagnostics ||= (diags.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>);
	}
	);

	<span class="hljs-keyword">if</span> (hasAnyDiagnostics) {
		<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showErrorMessage</span>(<span class="hljs-string">&quot;Error encountered during process&quot;</span>);
	}
	<span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">setStatusBarMessage</span>(<span class="hljs-string">&quot;Literate Process completed&quot;</span>, <span class="hljs-number">5000</span>);
	}
});
</code></pre>
</div></div><h2>Fragment tree provider</h2>
<p>The Literate Fragment Explorer needs a
<a href="https://code.visualstudio.com/api/extension-guides/tree-view"><code>TreeDataProvider</code></a>
implementation to present the fragment structure to Visual Studio Code so that
the data can be visualized in the <code>literateFragments</code> custom view.</p>
<p>The class <code>FragmentNodeProvider</code> implements a <code>TreeDataProvider</code> with
<code>FragmentNode</code> as the tree item.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment tree provider&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentNodeProvider</span> <span class="hljs-keyword">implements</span> vscode.<span class="hljs-property">TreeDataProvider</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;
{
	&lt;&lt;fragment node provider members&gt;&gt;
	&lt;&lt;fragment node provider <span class="hljs-variable constant_">API</span>&gt;&gt;
}
</code></pre>
</div></div><p>The constructor takes care of all necessary initialization.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node provider API&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
{
	&lt;&lt;initialize fragment node provider&gt;&gt;
}
</code></pre>
</div></div><p>The constructor for the <code>FragmentNodeProvider</code> creates an instance of the
<code>MarkdownIt</code> module, fully configured for our <strong>literate programming</strong> needs.
Additionally a <code>DiagnosticCollection</code> is created so that it can be passed on to
the <code>handleFragments</code> function that is utilized in the <code>FragmentNodeProvider</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;initialize fragment node provider&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">md</span> = <span class="hljs-title function_">createMarkdownItParserForLiterate</span>();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span> = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate-treeview&#x27;</span>);
</code></pre>
</div></div><p>This means we need two members to hold these instances.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node provider members&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">private</span> md : <span class="hljs-title class_">MarkdownIt</span>;
<span class="hljs-keyword">private</span> diagnostics : vscode.<span class="hljs-property">DiagnosticCollection</span>;
</code></pre>
</div></div><p>The API for <code>FragmentNodeProvider</code> gives as method to update the tree view</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node provider API&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-title function_">refresh</span>(): <span class="hljs-built_in">void</span> {
	&lt;&lt;refresh fragment node provider&gt;&gt;
}
</code></pre>
</div></div><p>The current implementation simply fires the <code>onDidChangeTreeData</code> event but
could do more work if needed. To that end there is a private member for emitting
the event, and the actual event to which the event emitter is published.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node provider members&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">private</span> <span class="hljs-attr">_onDidChangeTreeData</span>: vscode.<span class="hljs-property">EventEmitter</span>&lt;<span class="hljs-title class_">FragmentNode</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">void</span>&gt; = <span class="hljs-keyword">new</span> vscode.<span class="hljs-property">EventEmitter</span>&lt;<span class="hljs-title class_">FragmentNode</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">void</span>&gt;();
<span class="hljs-keyword">readonly</span> onDidChangeTreeData : vscode.<span class="hljs-property">Event</span>&lt;<span class="hljs-title class_">FragmentNode</span> | <span class="hljs-literal">undefined</span> | <span class="hljs-built_in">void</span>&gt; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onDidChangeTreeData</span>.<span class="hljs-property">event</span>;
</code></pre>
</div></div><p>With those two in place the <code>refresh</code> function can fire the event whenever
called.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;refresh fragment node provider&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-variable language_">this</span>.<span class="hljs-property">_onDidChangeTreeData</span>.<span class="hljs-title function_">fire</span>();
</code></pre>
</div></div><p>The <code>TreeDataProvider</code> implementation provided by <code>FragmentNodeProvider</code> is
completed by <code>getTreeItem</code> and <code>getChildren</code>. The first one is simple, it just
returns the element that is passed to it, as there is no need to find out more
information about this. Instead, elements have been already created by the
<code>getChildren</code> function, where all <code>FragmentNode</code> instances are created with all
the data necessary.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node provider API&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-title function_">getTreeItem</span>(element : <span class="hljs-title class_">FragmentNode</span>): vscode.<span class="hljs-property">TreeItem</span> {
	&lt;&lt;get fragment tree item&gt;&gt;
}
</code></pre>
</div></div><p>As said, the <code>getTreeItem</code> implementation remains simple</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get fragment tree item&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">return</span> element;
</code></pre>
</div></div><p>On the other hand the <code>getChildren</code> function is more involved. Its job is
simple: get all <code>FragmentNode</code>s that represent the direct children of the
element given.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node provider API&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">async</span> <span class="hljs-title function_">getChildren</span>(element? : <span class="hljs-title class_">FragmentNode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">FragmentNode</span>[]&gt;
{
	&lt;&lt;get direct children&gt;&gt;
}
</code></pre>
</div></div><p>When the workspace has no workspace folders at all there will be no children to
return, as there are no <strong>literate</strong> documents to begin with.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get direct children&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">if</span>(!vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> || (vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> &amp;&amp; vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-number">1</span>)) {
	vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">showInformationMessage</span>(<span class="hljs-string">&#x27;No fragments in empty workspace&#x27;</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>([]);
}
</code></pre>
</div></div><p>If we do have workspace folders, but no element is given to look for children we
need to look at the all the fragments available in all documents across all
workspace folders. If on the other hand an element is given then its children
are retrieved.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get direct children&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">if</span>(!element)
{
	&lt;&lt;get children <span class="hljs-keyword">for</span> workspace folders&gt;&gt;
}
<span class="hljs-keyword">else</span>
{
	&lt;&lt;get children <span class="hljs-keyword">for</span> element&gt;&gt;
}
</code></pre>
</div></div><p>When no element is passed we now we want the root of all the branches, where
each workspace folder is the root of its own branch.</p>
<p>To this end the children are all essentially the workspace folder names. Since
these are the work folders the fragments representing them have no <code>parentName</code>
specified. As <code>folderName</code> we pass on the workspace folder name. This is a
property all its children and the rest of its offspring inherit. The
<code>folderName</code> is used to find the correct workspace folder to search for the
given element and its offspring.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get children for workspace folders&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> wsFolder <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>)
{
    arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNode</span>(wsFolder.<span class="hljs-property">name</span>, <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">&#x27;$(book) (workspace folder)&#x27;</span>, <span class="hljs-literal">true</span>), <span class="hljs-string">&#x27;Workspace folder containing a literate project&#x27;</span>, vscode.<span class="hljs-property">TreeItemCollapsibleState</span>.<span class="hljs-property">Collapsed</span>, wsFolder.<span class="hljs-property">name</span>, <span class="hljs-literal">undefined</span>));
}
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(arr);
</code></pre>
</div></div><p>Getting the children for a given element is a bit more involved. First we set
up a constant <code>folderName</code> for ease of access. Then we also creat an array of
<code>FragmentNode</code>s.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get children for element&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">const</span> folderName : <span class="hljs-built_in">string</span> = element.<span class="hljs-property">folderName</span>;
<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">FragmentNode</span>&gt;();
</code></pre>
</div></div><p>We only want to parse <strong>literate</strong> files of the workspace folder the given
element is for, so we start by searching for the correct workspace folder for
our given element. With the <code>fragments</code> map of the workspace folder in hand we
can iterate over the keys in the <code>fragments</code> map.</p>
<p>There are essentially two cases we need to check for. If the given element has
no <code>parentName</code> set we know it is a fragment in the document level, so a
fragment that was created. In contrast for a fragment there are child fragments,
meaning that in the fragment code block other fragments were used. These are
presented in the tree view as children to that fragment.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get children for element&gt;&gt;=+</div><div class="code"><pre><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> fldr <span class="hljs-keyword">of</span> vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>)
{
	<span class="hljs-keyword">if</span> (fldr.<span class="hljs-property">name</span> === folderName) {
		&lt;&lt;get fragment family <span class="hljs-keyword">for</span> offspring search&gt;&gt;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> fragmentName <span class="hljs-keyword">of</span> fragments.<span class="hljs-title function_">keys</span>() )
		{
			<span class="hljs-keyword">if</span>(!element.<span class="hljs-property">parentName</span>) {
				&lt;&lt;create fragment node <span class="hljs-keyword">for</span> <span class="hljs-variable language_">document</span> level&gt;&gt;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fragmentName === element.<span class="hljs-property">label</span>) {
				&lt;&lt;create fragment node <span class="hljs-keyword">for</span> fragment parent&gt;&gt;
			}
		}
	}
}

<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(arr);
</code></pre>
</div></div><h3>Getting all fragments</h3>
<p>To find the fragment information to build <code>FragmentNode</code>s from iterate over the
<strong>literate</strong> files in the workspace folder that we determined we need to search.
Then build the fragment map based on the tokens generated by the iteration pass.
As a reminder the fragments map has the fragment name as key and the
corresponding <code>FragmentInformation</code> as the value to that key.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;get fragment family for offspring search&gt;&gt;=</div><div class="code"><pre><code>		<span class="hljs-keyword">let</span> <span class="hljs-attr">envList</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">GrabbedState</span>&gt;();
		<span class="hljs-keyword">await</span> <span class="hljs-title function_">iterateLiterateFiles</span>(fldr, <span class="hljs-literal">undefined</span>, envList, <span class="hljs-variable language_">this</span>.<span class="hljs-property">md</span>);
		<span class="hljs-keyword">const</span> fragments = <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleFragments</span>(fldr, envList, <span class="hljs-variable language_">this</span>.<span class="hljs-property">diagnostics</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>);
</code></pre>
</div></div><h3>TODO: build proper fragment hierarchy from fragments map</h3>
<p>Still to do. Right now essentially the map structure is shown.</p>
<h3>Fragment used in other fragment</h3>
<p>When we have found the fragment the passed in element represents we can find the
child fragment names, that is the fragment names used in this fragment. All
matches against <code>FRAGMENT_USE_IN_CODE_RE</code> are found and for each case a
corresponding <code>FragmentNode</code> is created to function as a child to our parent
element.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;create fragment node for fragment parent&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">if</span> (fragmentInfo) {
	<span class="hljs-keyword">const</span> casesToReplace = [...fragmentInfo.<span class="hljs-property">code</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-variable constant_">FRAGMENT_USE_IN_CODE_RE</span>)];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> match <span class="hljs-keyword">of</span> casesToReplace) {
		<span class="hljs-keyword">let</span> [tag, indent, tagName, root, add, ...rest] = match;
        arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNode</span>(tagName, <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">`$(symbol-file) <span class="hljs-subst">${fragmentInfo.literateFileName}</span>`</span>, <span class="hljs-literal">true</span>), <span class="hljs-string">`<span class="hljs-subst">${fragmentName}</span>`</span>, vscode.<span class="hljs-property">TreeItemCollapsibleState</span>.<span class="hljs-property">Collapsed</span>, folderName, element.<span class="hljs-property">label</span>));
	}
}
</code></pre>
</div></div><h3>Fragment on document level</h3>
<p>When the workspace folder is given as the element, or rather the <code>parentName</code>
of the given element is undefined, we have a fragment on document level. There
are two types of fragments we want to discern beetween: top level fragments, or
fragments that also tell us what file to create, and other fragments. A
<strong>literate</strong> document can contain multiple top level fragments. But each top
level fragment will generate only one source code file.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;create fragment node for document level&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">let</span> fragmentType : vscode.<span class="hljs-property">MarkdownString</span>;
<span class="hljs-keyword">let</span> fragmentInfo = fragments.<span class="hljs-title function_">get</span>(fragmentName) || <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">if</span> (fragmentInfo) {
	<span class="hljs-keyword">if</span>(fragmentName.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.*&quot;</span>) &gt;= <span class="hljs-number">0</span>)
	{
		fragmentType = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">`$(globe): <span class="hljs-subst">${fragmentInfo.literateFileName}</span>`</span>, <span class="hljs-literal">true</span>);
	}
	<span class="hljs-keyword">else</span>
	{
		fragmentType = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">MarkdownString</span>(<span class="hljs-string">`$(code): <span class="hljs-subst">${fragmentInfo.literateFileName}</span>`</span>, <span class="hljs-literal">true</span>);
	}
	arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNode</span>(fragmentName, fragmentType, fragmentInfo.<span class="hljs-property">literateFileName</span>, vscode.<span class="hljs-property">TreeItemCollapsibleState</span>.<span class="hljs-property">Collapsed</span>, folderName, element.<span class="hljs-property">label</span>));
}
</code></pre>
</div></div><h2>Fragment node for tree view</h2>
<p>Each node in the tree view represents a fragment. When the tree item is used to
denote a workspace folder the theme icon for <code>'book'</code> is used. Actual fragments
get the theme icon for <code>'code'</code>.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;fragment node&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">vscode.TreeItem</span>
{
	<span class="hljs-title function_">constructor</span> (
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> label : <span class="hljs-built_in">string</span>,
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> tooltip : vscode.<span class="hljs-property">MarkdownString</span>,
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> description : <span class="hljs-built_in">string</span>,
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> collapsibleState : vscode.<span class="hljs-property">TreeItemCollapsibleState</span>,
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">folderName</span>: <span class="hljs-built_in">string</span>,
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> parentName : <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>
	)
	{
		<span class="hljs-variable language_">super</span>(label, collapsibleState);
		<span class="hljs-variable language_">this</span>.<span class="hljs-property">tooltip</span> = tooltip;
		<span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> = description;
		<span class="hljs-variable language_">this</span>.<span class="hljs-property">iconPath</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentName</span> ? <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">ThemeIcon</span>(<span class="hljs-string">&#x27;code&#x27;</span>) : <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">ThemeIcon</span>(<span class="hljs-string">&#x27;book&#x27;</span>);
	}

	contextValue = <span class="hljs-string">&#x27;literate_fragment&#x27;</span>;
}
</code></pre>
</div></div><h2>registering FragmentNodeProvider</h2>
<p>The <code>FragmentNodeProvide</code> needs to be registered with Visual Studio Code so it
can work when literate files are found in a work space.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;register fragment tree view&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">const</span> fragmentNodeProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragmentNodeProvider</span>();
vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">registerTreeDataProvider</span>(<span class="hljs-string">&#x27;literateFragments&#x27;</span>, fragmentNodeProvider);
vscode.<span class="hljs-property">commands</span>.<span class="hljs-title function_">registerCommand</span>(<span class="hljs-string">&#x27;literateFragments.refreshEntry&#x27;</span>, <span class="hljs-function">() =&gt;</span> fragmentNodeProvider.<span class="hljs-title function_">refresh</span>());
</code></pre>
</div></div><h2>The extension file</h2>
<p>Our Visual Studio Code entry file is the <code>extension.ts</code> file. While developing
the plug-in the JavaScript version created from this, in <code>out/extension.js</code> is
set as the entry point for the extension, in <code>package.json</code>. But when it is
prepared for release on the Visual Studio Code marketplace this needs to be
changed to the minified and bundled version that gets realized as <code>out/main.js</code>.
This ensures, together with a properly set up <code>.vscodeignore</code> that the published
package stays small in size. Without that the package is easily over 2MB in
size, but properly configured it is under 400KB.</p>
<div class="codefragment"><div class="fragmentname">&lt;&lt;literate.*&gt;&gt;=</div><div class="code"><pre><code><span class="hljs-keyword">import</span> <span class="hljs-title class_">StateCore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/rules_core/state_core&#x27;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Token</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/token&#x27;</span>);
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">TextDecoder</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;util&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> vscode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vscode&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;

<span class="hljs-comment">// `import` here fails so instead we require the highlight module</span>
<span class="hljs-comment">// this way. Not sure why import fails. It would be great to find</span>
<span class="hljs-comment">// out the reason.</span>
<span class="hljs-keyword">const</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;highlight.js&#x27;</span>);

<span class="hljs-keyword">import</span> { grabberPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./grabber&#x27;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;markdown-it&quot;</span>);
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Renderer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;markdown-it/lib/renderer&#x27;</span>);

<span class="hljs-keyword">let</span> oldFence : <span class="hljs-title class_">Renderer</span>.<span class="hljs-property">RenderRule</span> | <span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">WriteRenderCallback</span> { (fname : <span class="hljs-built_in">string</span>, folderUri : vscode.<span class="hljs-property">Uri</span>, sourceUri : vscode.<span class="hljs-property">Uri</span>, content : <span class="hljs-built_in">string</span>) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt; };
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">WriteSourceCallback</span> { (workspaceFolder : vscode.<span class="hljs-property">WorkspaceFolder</span>, fragments : <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">FragmentInformation</span>&gt;) : <span class="hljs-title class_">Thenable</span>&lt;<span class="hljs-built_in">void</span>&gt; };

&lt;&lt;grabbed state <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;fragment information <span class="hljs-keyword">type</span>&gt;&gt;
&lt;&lt;fragment regular expressions&gt;&gt;

&lt;&lt;fragment node&gt;&gt;
&lt;&lt;fragment tree provider&gt;&gt;

&lt;&lt;render and collect state&gt;&gt;

&lt;&lt;handle fragments&gt;&gt;

&lt;&lt;write out source files&gt;&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>) {
	<span class="hljs-keyword">const</span> rootPath = (vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span> &amp;&amp; (vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>))
		? vscode.<span class="hljs-property">workspace</span>.<span class="hljs-property">workspaceFolders</span>[<span class="hljs-number">0</span>].<span class="hljs-property">uri</span>.<span class="hljs-property">fsPath</span> : <span class="hljs-literal">undefined</span>;

	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Ready to do some Literate Programming&#x27;</span>);
	<span class="hljs-keyword">const</span> diagnostics = vscode.<span class="hljs-property">languages</span>.<span class="hljs-title function_">createDiagnosticCollection</span>(<span class="hljs-string">&#x27;literate&#x27;</span>);
	<span class="hljs-comment">//setupLanguageMapping();</span>

	&lt;&lt;register literate.<span class="hljs-property">process</span>&gt;&gt;
	&lt;&lt;register fragment tree view&gt;&gt;

	<span class="hljs-keyword">if</span> (vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>) {
		<span class="hljs-title function_">updateDiagnostics</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-property">activeTextEditor</span>.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
	}
	context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(vscode.<span class="hljs-property">window</span>.<span class="hljs-title function_">onDidChangeActiveTextEditor</span>(<span class="hljs-function"><span class="hljs-params">editor</span> =&gt;</span> {
		<span class="hljs-keyword">if</span> (editor) {
			<span class="hljs-title function_">updateDiagnostics</span>(editor.<span class="hljs-property">document</span>.<span class="hljs-property">uri</span>, diagnostics, <span class="hljs-literal">undefined</span>);
		}
	}));

	context.<span class="hljs-property">subscriptions</span>.<span class="hljs-title function_">push</span>(literateProcessDisposable);

	<span class="hljs-keyword">return</span> {
		<span class="hljs-title function_">extendMarkdownIt</span>(<span class="hljs-params">md: <span class="hljs-built_in">any</span></span>) {
			md.<span class="hljs-title function_">use</span>(grabberPlugin);
			oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
			md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
			<span class="hljs-keyword">return</span> md;
		}
	};
};

<span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/naming-convention</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">codeFragmentCleanup</span>(<span class="hljs-params">_: <span class="hljs-built_in">string</span>, p1 : <span class="hljs-built_in">string</span>, __: <span class="hljs-built_in">number</span>, ___: <span class="hljs-built_in">string</span></span>) {
	<span class="hljs-keyword">let</span> cleaned = p1.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/&lt;.*?&gt;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;span class=&quot;fragmentuse&quot;&gt;<span class="hljs-subst">${cleaned}</span>&lt;/span&gt;`</span>;
}

&lt;&lt;renderCodeFence rule&gt;&gt;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createMarkdownItParserForLiterate</span>(<span class="hljs-params"></span>) : <span class="hljs-title class_">MarkdownIt</span>
{
	<span class="hljs-keyword">const</span> md : <span class="hljs-title class_">MarkdownIt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
					<span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, lang: <span class="hljs-built_in">string</span>, attrs: <span class="hljs-built_in">string</span></span>) {
						<span class="hljs-keyword">if</span>(lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
							<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&lt;code&gt;&#x27;</span> +
							hljs.<span class="hljs-title function_">highlight</span>(str, {language : lang}).<span class="hljs-property">value</span> +
							<span class="hljs-string">&#x27;&lt;/code&gt;&lt;/pre&gt;&#x27;</span>;
						}
						<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre title=&quot;&#x27;</span> + attrs + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span> + md.<span class="hljs-property">utils</span>.escapeHtml(str) + <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>;
					}
			
				})
				.<span class="hljs-title function_">use</span>(grabberPlugin);
			
			oldFence = md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span>;
			md.<span class="hljs-property">renderer</span>.<span class="hljs-property">rules</span>.<span class="hljs-property">fence</span> = renderCodeFence;
	<span class="hljs-keyword">return</span> md;
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDiagnostics</span>(<span class="hljs-params">uri: vscode.Uri, collection: vscode.DiagnosticCollection, diagnostic : vscode.Diagnostic | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">void</span> {
	<span class="hljs-keyword">if</span> (uri) {
		<span class="hljs-keyword">if</span> (diagnostic) {
			<span class="hljs-keyword">const</span> diags = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(collection.<span class="hljs-title function_">get</span>(uri) || []);
			diags.<span class="hljs-title function_">push</span>(diagnostic);
			collection.<span class="hljs-title function_">set</span>(uri, diags);
		}
	} <span class="hljs-keyword">else</span> {
		collection.<span class="hljs-title function_">clear</span>();
	}
}

<span class="hljs-comment">/**
 * Create diagnostic for a given token with message.
 * <span class="hljs-doctag">@param</span> token Token that carries the faulty code fragment
 * <span class="hljs-doctag">@param</span> message Error message
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createErrorDiagnostic</span>(<span class="hljs-params">token: Token, message: <span class="hljs-built_in">string</span></span>) : vscode.<span class="hljs-property">Diagnostic</span> {
	<span class="hljs-keyword">let</span> range = <span class="hljs-title function_">fragmentRange</span>(token);
	<span class="hljs-keyword">let</span> <span class="hljs-attr">diagnostic</span>: vscode.<span class="hljs-property">Diagnostic</span> = {
		<span class="hljs-attr">severity</span>: vscode.<span class="hljs-property">DiagnosticSeverity</span>.<span class="hljs-property">Error</span>,
		<span class="hljs-attr">message</span>: message,
		<span class="hljs-attr">range</span>: range
	};

	<span class="hljs-keyword">return</span> diagnostic;
}

<span class="hljs-comment">/**
 * Give the location of the line in the Markup document that contains the
 * tag declaration.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragment</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
	<span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">0</span>]) : -<span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> linenumber;
}

<span class="hljs-comment">/**
 * Give the location of the last line in the Markup document that contains the
 * code fragment.
 * <span class="hljs-doctag">@param</span> token Token to extract code location from
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">locationOfFragmentEnd</span>(<span class="hljs-params">token: Token</span>): <span class="hljs-built_in">number</span> {
	<span class="hljs-keyword">let</span> linenumber = token.<span class="hljs-property">map</span> ? (token.<span class="hljs-property">map</span>[<span class="hljs-number">1</span>] ) : -<span class="hljs-number">1</span>;
	<span class="hljs-keyword">return</span> linenumber;
}


<span class="hljs-comment">/**
 * Give range for the code fragment, including tag.
 * <span class="hljs-doctag">@param</span> token Token to create range for
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fragmentRange</span>(<span class="hljs-params">token: Token</span>): vscode.<span class="hljs-property">Range</span> {
	<span class="hljs-keyword">let</span> startTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>) + <span class="hljs-number">2</span>;
	<span class="hljs-keyword">let</span> endTagName = token.<span class="hljs-property">info</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>) - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragment</span>(token), startTagName);
	<span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Position</span>(<span class="hljs-title function_">locationOfFragmentEnd</span>(token), endTagName);
	<span class="hljs-keyword">let</span> <span class="hljs-attr">range</span>: vscode.<span class="hljs-property">Range</span> = <span class="hljs-keyword">new</span> vscode.<span class="hljs-title class_">Range</span>(start, end);
	<span class="hljs-keyword">return</span> range;
}

<span class="hljs-comment">/*
let languageMapping = new Map&lt;string, string&gt;();
function setupLanguageMapping() {
	languageMapping.set(&quot;csharp&quot;, &quot;cs&quot;);
}

function extensionForLanguage(lang: string): string
{
	lang = lang.trim();
	if (lang.length &lt;= 2) {
		return lang;
	}

	if (languageMapping.has(lang)) {
		let extension = languageMapping.get(lang);
		if (extension) {
			return extension;
		}
	}

	return &#x27;xx&#x27;;
}

*/</span>

<span class="hljs-comment">// this method is called when your extension is deactivated</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deactivate</span>(<span class="hljs-params"></span>) {}

</code></pre>
</div></div>
		</body>
	</html>